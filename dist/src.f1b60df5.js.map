{"version":3,"sources":["../src/App.riot","../node_modules/riot/riot.esm.js","../src/index.js","../node_modules/parcel-bundler/src/builtins/bundle-url.js","../node_modules/parcel-bundler/src/builtins/bundle-loader.js","../node_modules/parcel-bundler/src/builtins/loaders/browser/wasm-loader.js"],"names":["add","template","expressionTypes","bindingTypes","getComponent","TEXT","scope","props","message","EVENT","console","log","camelToDashCase","string","replace","toLowerCase","dashToCamelCase","_","c","toUpperCase","DOMattributesToObject","element","Array","from","attributes","reduce","acc","attribute","name","value","moveChildren","source","target","firstChild","appendChild","cleanNode","node","clearChildren","childNodes","children","forEach","removeNode","parentNode","remove","removeChild","EACH","IF","SIMPLE","TAG","SLOT","ATTRIBUTE","VALUE","createTemplateMeta","componentTemplate","fragment","dom","cloneNode","avoidDOMInjection","indexOf","slice","append","get","parent","start","end","before","isSelect","noSelection","child","insertBefore","selected","selectedIndex","call","querySelectorAll","eqeq","a","b","identity","O","indexOf$1","moreNodes","moreStart","moreEnd","lessNodes","lessStart","lessEnd","compare","length","m","l","isReversed","futureNodes","futureEnd","currentNodes","currentStart","currentEnd","next","list","i","nextSibling","drop","DELETION","INSERTION","SKIP","SKIP_OND","HS","futureStart","futureChanges","currentChanges","k","minLen","link","tresh","nodes","index","idxInOld","findK","newi","oldi","prev","diff","ptr","OND","rows","cols","d","r","pv","cv","pd","v","outer","diffIdx","applyDiff","currentLength","live","currentIndex","push","ktr","j","lo","hi","mid","smartDiff","dropChild","domdiff","options","currentSame","futureSame","checkType","type","isSvg","el","owner","ownerSVGElement","isTemplate","isNil","content","isFunction","isBoolean","isObject","UNMOUNT_SCOPE","Symbol","EachBinding","Object","seal","mount","parentScope","update","placeholder","childrenMap","collection","evaluate","items","createPatch","newChildrenMap","batches","patch","values","fn","unmount","redundant","item","info","pop","context","mustFilterItem","condition","Boolean","extendScope","_ref","itemName","indexName","binding","getKey","root","isTemplateTag","Map","create","key","oldItem","clone","mustMount","meta","delete","set","_ref2","document","createTextNode","assign","createDOM","IfBinding","pristine","mustUnmount","create$1","panic","Error","memoize","cache","cached","val","has","evaluateAttributeExpressions","REMOVE_ATTRIBUTE","SET_ATTIBUTE","ElementProto","Element","prototype","isNativeHtmlProperty","hasOwnProperty","setAllAttributes","entries","attributeExpression","removeAllAttributes","newAttributes","oldAttributes","newKeys","keys","filter","includes","removeAttribute","oldValue","getMethod","normalizeValue","RE_EVENTS_PREFIX","getCallbackAndOptions","isArray","EventListener","handleEvent","event","ListenersWeakMap","WeakMap","createListener","listener","eventExpression","normalizedEventName","eventListener","callback","handler","mustAddEvent","removeEventListener","addEventListener","normalizeStringValue","getTextNode","childNodeIndex","nodeType","Node","COMMENT_NODE","textNode","replaceChild","textExpression","data","valueExpression","expression","expressions","Expression","apply","create$2","flattenCollectionMethods","methods","method","map","create$3","COMPONENTS_IMPLEMENTATION_MAP","DOM_COMPONENT_INSTANCE_PROPERTY","PLUGINS_SET","Set","IS_DIRECTIVE","VALUE_ATTRIBUTE","MOUNT_METHOD_KEY","UPDATE_METHOD_KEY","UNMOUNT_METHOD_KEY","SHOULD_UPDATE_KEY","ON_BEFORE_MOUNT_KEY","ON_MOUNTED_KEY","ON_BEFORE_UPDATE_KEY","ON_UPDATED_KEY","ON_BEFORE_UNMOUNT_KEY","ON_UNMOUNTED_KEY","PROPS_KEY","STATE_KEY","SLOTS_KEY","ROOT_KEY","IS_PURE_SYMBOL","for","PARENT_KEY_SYMBOL","ATTRIBUTES_KEY_SYMBOL","TEMPLATE_KEY_SYMBOL","globals","freeze","__proto__","extendParentScope","attr","getRealParent","undefined","SlotBinding","getTemplateScope","templateData","slots","find","id","realParent","create$6","html","bindings","moveSlotInnerContent","mustRemoveRoot","slot","createSlot","getTag","component","slotsToMarkup","slotBindings","concat","TagBinding","tag","keepRootTag","create$4","fixTextExpressionsOffset","textExpressionsOffset","e","create$5","templateTagOffset","selector","redundantAttribute","querySelector","bindingExpressions","createHTMLTree","createElement","innerHTML","createSVGTree","container","svgNode","ownerDocument","importNode","window","DOMParser","parseFromString","documentElement","createDOMTree","injectDOM","createTemplateDOM","TemplateChunk","Math","max","bindingsData","DOMBindings","createBinding","createExpression","noop","autobindMethods","bind","callOrAssign","constructor","defineProperty","enumerable","writable","configurable","defineProperties","properties","defineDefaults","defaults","domToArray","els","test","toString","$","ctx","normalize","parseNodes","names","n","attrs","prop","setAttribute","CSS_BY_NAME","STYLE_NODE_SELECTOR","getStyleNode","style","head","cssManager","css","inject","join","curry","_len","arguments","_key","_len2","args","_key2","getName","tagName","COMPONENT_CORE_HELPERS","$$","PURE_COMPONENT_API","COMPONENT_LIFECYCLE_METHODS","MOCKED_TEMPLATE_INTERFACE","evaluateInitialProps","initialProps","bindDOMNodeToComponentObject","createCoreAPIMethods","mapFunction","componentTemplateFactory","components","createPureComponent","pureFactoryFunction","createComponent","exports","templateFn","createSubcomponents","_ref3","componentAPI","defineComponent","state","preserveRoot","_ref4","enhanceComponentAPI","createAttributeBindings","_ref5","runPlugins","computeState","oldState","newState","addCssHook","_ref6","newProps","mountComponent","componentName","compose","fns","f","g","DOM_COMPONENT_INSTANCE_PROPERTY$1","COMPONENTS_IMPLEMENTATION_MAP$1","PLUGINS_SET$1","register","unregister","keepRootElement","install","plugin","uninstall","implementation","_temp","pure","func","version","__","App","bundleURL","getBundleURLCached","getBundleURL","err","matches","stack","match","getBaseURL","url","require","loadBundlesLazy","bundles","Promise","resolve","code","LazyPromise","reject","loadBundles","then","all","loadBundle","bundleLoaders","registerBundleLoader","loader","module","load","bundle","substring","lastIndexOf","bundleLoader","resolved","catch","executor","promise","onSuccess","onError","fetch","res","WebAssembly","instantiateStreaming","arrayBuffer","instantiate","wasmModule","instance"],"mappings":"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","file":"src.f1b60df5.js","sourceRoot":"../public","sourcesContent":["import { add } from '../rustess/src/lib.rs'\n\nexport default {\n  'css': null,\n\n  'exports': {\n    add\n  },\n\n  'template': function(template, expressionTypes, bindingTypes, getComponent) {\n    return template('<p expr0=\"expr0\"> </p><button expr1=\"expr1\">Log add</button>', [{\n      'redundantAttribute': 'expr0',\n      'selector': '[expr0]',\n\n      'expressions': [{\n        'type': expressionTypes.TEXT,\n        'childNodeIndex': 0,\n\n        'evaluate': function(scope) {\n          return scope.props.message;\n        }\n      }]\n    }, {\n      'redundantAttribute': 'expr1',\n      'selector': '[expr1]',\n\n      'expressions': [{\n        'type': expressionTypes.EVENT,\n        'name': 'onclick',\n\n        'evaluate': function(scope) {\n          return ()=> console.log(scope.add(1,2));\n        }\n      }]\n    }]);\n  },\n\n  'name': 'app'\n};","/* Riot v4.13.4, @license MIT */\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\n\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value;\n    return acc;\n  }, {});\n}\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\n// Ignore this helper because it's needed only for svg tags\n\nfunction moveChildren(source, target) {\n  if (source.firstChild) {\n    target.appendChild(source.firstChild);\n    moveChildren(source, target);\n  }\n}\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\n\nfunction cleanNode(node) {\n  clearChildren(node.childNodes);\n}\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\n\nfunction clearChildren(children) {\n  Array.from(children).forEach(removeNode);\n}\n/**\n * Remove a node from the DOM\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\n\nfunction removeNode(node) {\n  const {\n    parentNode\n  } = node;\n  if (node.remove) node.remove();\n  /* istanbul ignore else */\n  else if (parentNode) parentNode.removeChild(node);\n}\n\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\nvar bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n};\n\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nvar expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n};\n\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk\n */\nfunction createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true);\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    children: Array.from(fragment.childNodes)\n  };\n}\n\nconst {\n  indexOf,\n  slice\n} = [];\n\nconst append = (get, parent, children, start, end, before) => {\n  const isSelect = ('selectedIndex' in parent);\n  let noSelection = isSelect;\n\n  while (start < end) {\n    const child = get(children[start], 1);\n    parent.insertBefore(child, before);\n\n    if (isSelect && noSelection && child.selected) {\n      noSelection = !noSelection;\n      let {\n        selectedIndex\n      } = parent;\n      parent.selectedIndex = selectedIndex < 0 ? start : indexOf.call(parent.querySelectorAll('option'), child);\n    }\n\n    start++;\n  }\n};\nconst eqeq = (a, b) => a == b;\nconst identity = O => O;\nconst indexOf$1 = (moreNodes, moreStart, moreEnd, lessNodes, lessStart, lessEnd, compare) => {\n  const length = lessEnd - lessStart;\n  /* istanbul ignore if */\n\n  if (length < 1) return -1;\n\n  while (moreEnd - moreStart >= length) {\n    let m = moreStart;\n    let l = lessStart;\n\n    while (m < moreEnd && l < lessEnd && compare(moreNodes[m], lessNodes[l])) {\n      m++;\n      l++;\n    }\n\n    if (l === lessEnd) return moreStart;\n    moreStart = m + 1;\n  }\n\n  return -1;\n};\nconst isReversed = (futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare) => {\n  while (currentStart < currentEnd && compare(currentNodes[currentStart], futureNodes[futureEnd - 1])) {\n    currentStart++;\n    futureEnd--;\n  }\n  return futureEnd === 0;\n};\nconst next = (get, list, i, length, before) => i < length ? get(list[i], 0) : 0 < i ? get(list[i - 1], -0).nextSibling : before;\nconst remove = (get, children, start, end) => {\n  while (start < end) drop(get(children[start++], -1));\n}; // - - - - - - - - - - - - - - - - - - -\n// diff related constants and utilities\n// - - - - - - - - - - - - - - - - - - -\n\nconst DELETION = -1;\nconst INSERTION = 1;\nconst SKIP = 0;\nconst SKIP_OND = 50;\n\nconst HS = (futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges) => {\n  let k = 0;\n  /* istanbul ignore next */\n\n  let minLen = futureChanges < currentChanges ? futureChanges : currentChanges;\n  const link = Array(minLen++);\n  const tresh = Array(minLen);\n  tresh[0] = -1;\n\n  for (let i = 1; i < minLen; i++) tresh[i] = currentEnd;\n\n  const nodes = currentNodes.slice(currentStart, currentEnd);\n\n  for (let i = futureStart; i < futureEnd; i++) {\n    const index = nodes.indexOf(futureNodes[i]);\n\n    if (-1 < index) {\n      const idxInOld = index + currentStart;\n      k = findK(tresh, minLen, idxInOld);\n      /* istanbul ignore else */\n\n      if (-1 < k) {\n        tresh[k] = idxInOld;\n        link[k] = {\n          newi: i,\n          oldi: idxInOld,\n          prev: link[k - 1]\n        };\n      }\n    }\n  }\n\n  k = --minLen;\n  --currentEnd;\n\n  while (tresh[k] > currentEnd) --k;\n\n  minLen = currentChanges + futureChanges - k;\n  const diff = Array(minLen);\n  let ptr = link[k];\n  --futureEnd;\n\n  while (ptr) {\n    const {\n      newi,\n      oldi\n    } = ptr;\n\n    while (futureEnd > newi) {\n      diff[--minLen] = INSERTION;\n      --futureEnd;\n    }\n\n    while (currentEnd > oldi) {\n      diff[--minLen] = DELETION;\n      --currentEnd;\n    }\n\n    diff[--minLen] = SKIP;\n    --futureEnd;\n    --currentEnd;\n    ptr = ptr.prev;\n  }\n\n  while (futureEnd >= futureStart) {\n    diff[--minLen] = INSERTION;\n    --futureEnd;\n  }\n\n  while (currentEnd >= currentStart) {\n    diff[--minLen] = DELETION;\n    --currentEnd;\n  }\n\n  return diff;\n}; // this is pretty much the same petit-dom code without the delete map part\n// https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L556-L561\n\n\nconst OND = (futureNodes, futureStart, rows, currentNodes, currentStart, cols, compare) => {\n  const length = rows + cols;\n  const v = [];\n  let d, k, r, c, pv, cv, pd;\n\n  outer: for (d = 0; d <= length; d++) {\n    /* istanbul ignore if */\n    if (d > SKIP_OND) return null;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    cv = v[d] = [];\n\n    for (k = -d; k <= d; k += 2) {\n      if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n        c = pv[pd + k + 1];\n      } else {\n        c = pv[pd + k - 1] + 1;\n      }\n\n      r = c - k;\n\n      while (c < cols && r < rows && compare(currentNodes[currentStart + c], futureNodes[futureStart + r])) {\n        c++;\n        r++;\n      }\n\n      if (c === cols && r === rows) {\n        break outer;\n      }\n\n      cv[d + k] = c;\n    }\n  }\n\n  const diff = Array(d / 2 + length / 2);\n  let diffIdx = diff.length - 1;\n\n  for (d = v.length - 1; d >= 0; d--) {\n    while (c > 0 && r > 0 && compare(currentNodes[currentStart + c - 1], futureNodes[futureStart + r - 1])) {\n      // diagonal edge = equality\n      diff[diffIdx--] = SKIP;\n      c--;\n      r--;\n    }\n\n    if (!d) break;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    k = c - r;\n\n    if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n      // vertical edge = insertion\n      r--;\n      diff[diffIdx--] = INSERTION;\n    } else {\n      // horizontal edge = deletion\n      c--;\n      diff[diffIdx--] = DELETION;\n    }\n  }\n\n  return diff;\n};\n\nconst applyDiff = (diff, get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before) => {\n  const live = [];\n  const length = diff.length;\n  let currentIndex = currentStart;\n  let i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        futureStart++;\n        currentIndex++;\n        break;\n\n      case INSERTION:\n        // TODO: bulk appends for sequential nodes\n        live.push(futureNodes[futureStart]);\n        append(get, parentNode, futureNodes, futureStart++, futureStart, currentIndex < currentLength ? get(currentNodes[currentIndex], 0) : before);\n        break;\n\n      case DELETION:\n        currentIndex++;\n        break;\n    }\n  }\n\n  i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        currentStart++;\n        break;\n\n      case DELETION:\n        // TODO: bulk removes for sequential nodes\n        if (-1 < live.indexOf(currentNodes[currentStart])) currentStart++;else remove(get, currentNodes, currentStart++, currentStart);\n        break;\n    }\n  }\n};\n\nconst findK = (ktr, length, j) => {\n  let lo = 1;\n  let hi = length;\n\n  while (lo < hi) {\n    const mid = (lo + hi) / 2 >>> 0;\n    if (j < ktr[mid]) hi = mid;else lo = mid + 1;\n  }\n\n  return lo;\n};\n\nconst smartDiff = (get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before) => {\n  applyDiff(OND(futureNodes, futureStart, futureChanges, currentNodes, currentStart, currentChanges, compare) || HS(futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges), get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before);\n};\n\nconst drop = node => (node.remove || dropChild).call(node);\n\nfunction dropChild() {\n  const {\n    parentNode\n  } = this;\n  /* istanbul ignore else */\n\n  if (parentNode) parentNode.removeChild(this);\n}\n\n/*! (c) 2018 Andrea Giammarchi (ISC) */\n\nconst domdiff = (parentNode, // where changes happen\ncurrentNodes, // Array of current items/nodes\nfutureNodes, // Array of future items/nodes\noptions // optional object with one of the following properties\n//  before: domNode\n//  compare(generic, generic) => true if same generic\n//  node(generic) => Node\n) => {\n  if (!options) options = {};\n  const compare = options.compare || eqeq;\n  const get = options.node || identity;\n  const before = options.before == null ? null : get(options.before, 0);\n  const currentLength = currentNodes.length;\n  let currentEnd = currentLength;\n  let currentStart = 0;\n  let futureEnd = futureNodes.length;\n  let futureStart = 0; // common prefix\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentStart], futureNodes[futureStart])) {\n    currentStart++;\n    futureStart++;\n  } // common suffix\n\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentEnd - 1], futureNodes[futureEnd - 1])) {\n    currentEnd--;\n    futureEnd--;\n  }\n\n  const currentSame = currentStart === currentEnd;\n  const futureSame = futureStart === futureEnd; // same list\n\n  if (currentSame && futureSame) return futureNodes; // only stuff to add\n\n  if (currentSame && futureStart < futureEnd) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentStart, currentLength, before));\n    return futureNodes;\n  } // only stuff to remove\n\n\n  if (futureSame && currentStart < currentEnd) {\n    remove(get, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  }\n\n  const currentChanges = currentEnd - currentStart;\n  const futureChanges = futureEnd - futureStart;\n  let i = -1; // 2 simple indels: the shortest sequence is a subsequence of the longest\n\n  if (currentChanges < futureChanges) {\n    i = indexOf$1(futureNodes, futureStart, futureEnd, currentNodes, currentStart, currentEnd, compare); // inner diff\n\n    if (-1 < i) {\n      append(get, parentNode, futureNodes, futureStart, i, get(currentNodes[currentStart], 0));\n      append(get, parentNode, futureNodes, i + currentChanges, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n      return futureNodes;\n    }\n  }\n  /* istanbul ignore else */\n  else if (futureChanges < currentChanges) {\n      i = indexOf$1(currentNodes, currentStart, currentEnd, futureNodes, futureStart, futureEnd, compare); // outer diff\n\n      if (-1 < i) {\n        remove(get, currentNodes, currentStart, i);\n        remove(get, currentNodes, i + futureChanges, currentEnd);\n        return futureNodes;\n      }\n    } // common case with one replacement for many nodes\n  // or many nodes replaced for a single one\n\n  /* istanbul ignore else */\n\n\n  if (currentChanges < 2 || futureChanges < 2) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, get(currentNodes[currentStart], 0));\n    remove(get, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  } // the half match diff part has been skipped in petit-dom\n  // https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L391-L397\n  // accordingly, I think it's safe to skip in here too\n  // if one day it'll come out like the speediest thing ever to do\n  // then I might add it in here too\n  // Extra: before going too fancy, what about reversed lists ?\n  //        This should bail out pretty quickly if that's not the case.\n\n\n  if (currentChanges === futureChanges && isReversed(futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare)) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n    return futureNodes;\n  } // last resort through a smart diff\n\n\n  smartDiff(get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before);\n  return futureNodes;\n};\n\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type;\n}\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\n\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n  return !!owner || owner === null;\n}\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\n\nfunction isTemplate(el) {\n  return !isNil(el.content);\n}\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\n\nfunction isFunction(value) {\n  return checkType(value, 'function');\n}\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\n\nfunction isBoolean(value) {\n  return checkType(value, 'boolean');\n}\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\n\nfunction isObject(value) {\n  return !isNil(value) && checkType(value, 'object');\n}\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\n\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\n\nconst UNMOUNT_SCOPE = Symbol('unmount');\nconst EachBinding = Object.seal({\n  // dynamic binding properties\n  // childrenMap: null,\n  // node: null,\n  // root: null,\n  // condition: null,\n  // evaluate: null,\n  // template: null,\n  // isTemplateTag: false,\n  nodes: [],\n\n  // getKey: null,\n  // indexName: null,\n  // itemName: null,\n  // afterPlaceholder: null,\n  // placeholder: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const {\n      placeholder,\n      nodes,\n      childrenMap\n    } = this;\n    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);\n    const items = collection ? Array.from(collection) : [];\n    const parent = placeholder.parentNode; // prepare the diffing\n\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes\n\n    domdiff(parent, nodes, futureNodes, {\n      before: placeholder,\n      node: patch(Array.from(childrenMap.values()), parentScope)\n    }); // trigger the mounts and the updates\n\n    batches.forEach(fn => fn()); // update the children map\n\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.update(UNMOUNT_SCOPE, parentScope);\n    return this;\n  }\n\n});\n/**\n * Patch the DOM while diffing\n * @param   {TemplateChunk[]} redundant - redundant tepmplate chunks\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\n\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      const element = redundant.pop();\n\n      if (element) {\n        const {\n          template,\n          context\n        } = element; // notice that we pass null as last argument because\n        // the root node and its children will be removed by domdiff\n\n        template.unmount(context, parentScope, null);\n      }\n    }\n\n    return item;\n  };\n}\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\n\n\nfunction mustFilterItem(condition, context) {\n  return condition ? Boolean(condition(context)) === false : false;\n}\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\n\n\nfunction extendScope(scope, _ref) {\n  let {\n    itemName,\n    indexName,\n    index,\n    item\n  } = _ref;\n  scope[itemName] = item;\n  if (indexName) scope[indexName] = index;\n  return scope;\n}\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EeachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\n\n\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root,\n    isTemplateTag\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n\n    if (mustFilterItem(condition, context)) {\n      return;\n    }\n\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = oldItem ? componentTemplate.el : root.cloneNode();\n    const mustMount = !oldItem;\n    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : {};\n\n    if (mustMount) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope, meta));\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    } // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n\n\n    if (isTemplateTag) {\n      const children = meta.children || componentTemplate.children;\n      futureNodes.push(...children);\n    } else {\n      futureNodes.push(el);\n    } // delete the old item from the children map\n\n\n    childrenMap.delete(key); // update the children map\n\n    newChildrenMap.set(key, {\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  };\n}\n\nfunction create(node, _ref2) {\n  let {\n    evaluate,\n    condition,\n    itemName,\n    indexName,\n    getKey,\n    template\n  } = _ref2;\n  const placeholder = document.createTextNode('');\n  const parent = node.parentNode;\n  const root = node.cloneNode();\n  parent.insertBefore(placeholder, node);\n  removeNode(node);\n  return Object.assign({}, EachBinding, {\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: isTemplate(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  });\n}\n\n/**\n * Binding responsible for the `if` directive\n */\n\nconst IfBinding = Object.seal({\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // isTemplateTag: false,\n  // placeholder: null,\n  // template: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n\n    const mount = () => {\n      const pristine = this.node.cloneNode();\n      this.placeholder.parentNode.insertBefore(pristine, this.placeholder);\n      this.template = this.template.clone();\n      this.template.mount(pristine, scope, parentScope);\n    };\n\n    switch (true) {\n      case mustMount:\n        mount();\n        break;\n\n      case mustUnmount:\n        this.unmount(scope);\n        break;\n\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope, true);\n    return this;\n  }\n\n});\nfunction create$1(node, _ref) {\n  let {\n    evaluate,\n    template\n  } = _ref;\n  const parent = node.parentNode;\n  const placeholder = document.createTextNode('');\n  parent.insertBefore(placeholder, node);\n  removeNode(node);\n  return Object.assign({}, IfBinding, {\n    node,\n    evaluate,\n    placeholder,\n    template: template.createDOM(node)\n  });\n}\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @returns { undefined } hoppla.. at this point the program should stop working\n */\n\nfunction panic(message) {\n  throw new Error(message);\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\n\nfunction memoize(fn) {\n  const cache = new Map();\n\n  const cached = val => {\n    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);\n  };\n\n  cached.cache = cache;\n  return cached;\n}\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\n\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {\n      value,\n      type\n    } = attribute;\n\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === ATTRIBUTE:\n        return Object.assign({}, acc, value);\n      // value attribute\n\n      case type === VALUE:\n        acc.value = attribute.value;\n        break;\n      // normal attributes\n\n      default:\n        acc[dashToCamelCase(attribute.name)] = attribute.value;\n    }\n\n    return acc;\n  }, {});\n}\n\nconst REMOVE_ATTRIBUTE = 'removeAttribute';\nconst SET_ATTIBUTE = 'setAttribute';\nconst ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;\nconst isNativeHtmlProperty = memoize(name => ElementProto.hasOwnProperty(name)); // eslint-disable-line\n\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\n\nfunction setAllAttributes(node, attributes) {\n  Object.entries(attributes).forEach((_ref) => {\n    let [name, value] = _ref;\n    return attributeExpression(node, {\n      name\n    }, value);\n  });\n}\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} newAttributes - object containing all the new attribute names\n * @param   {Object} oldAttributes - object containing all the old attribute names\n * @returns {undefined} sorry it's a void function :(\n */\n\n\nfunction removeAllAttributes(node, newAttributes, oldAttributes) {\n  const newKeys = newAttributes ? Object.keys(newAttributes) : [];\n  Object.keys(oldAttributes).filter(name => !newKeys.includes(name)).forEach(attribute => node.removeAttribute(attribute));\n}\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\n\n\nfunction attributeExpression(node, _ref2, value, oldValue) {\n  let {\n    name\n  } = _ref2;\n\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    if (oldValue) {\n      // remove all the old attributes\n      removeAllAttributes(node, value, oldValue);\n    } // is the value still truthy?\n\n\n    if (value) {\n      setAllAttributes(node, value);\n    }\n\n    return;\n  } // handle boolean attributes\n\n\n  if (!isNativeHtmlProperty(name) && (isBoolean(value) || isObject(value) || isFunction(value))) {\n    node[name] = value;\n  }\n\n  node[getMethod(value)](name, normalizeValue(name, value));\n}\n/**\n * Get the attribute modifier method\n * @param   {*} value - if truthy we return `setAttribute` othewise `removeAttribute`\n * @returns {string} the node attribute modifier method name\n */\n\nfunction getMethod(value) {\n  return isNil(value) || value === false || value === '' || isObject(value) || isFunction(value) ? REMOVE_ATTRIBUTE : SET_ATTIBUTE;\n}\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\n\n\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  if (value === true) return name;\n  return value;\n}\n\nconst RE_EVENTS_PREFIX = /^on/;\n\nconst getCallbackAndOptions = value => Array.isArray(value) ? value : [value, false]; // see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\n\n\nconst EventListener = {\n  handleEvent(event) {\n    this[event.type](event);\n  }\n\n};\nconst ListenersWeakMap = new WeakMap();\n\nconst createListener = node => {\n  const listener = Object.create(EventListener);\n  ListenersWeakMap.set(node, listener);\n  return listener;\n};\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {value} the callback just received\n */\n\n\nfunction eventExpression(node, _ref, value) {\n  let {\n    name\n  } = _ref;\n  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');\n  const eventListener = ListenersWeakMap.get(node) || createListener(node);\n  const [callback, options] = getCallbackAndOptions(value);\n  const handler = eventListener[normalizedEventName];\n  const mustRemoveEvent = handler && !callback;\n  const mustAddEvent = callback && !handler;\n\n  if (mustRemoveEvent) {\n    node.removeEventListener(normalizedEventName, eventListener);\n  }\n\n  if (mustAddEvent) {\n    node.addEventListener(normalizedEventName, eventListener, options);\n  }\n\n  eventListener[normalizedEventName] = callback;\n}\n\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\n\nfunction normalizeStringValue(value) {\n  return isNil(value) ? '' : value;\n}\n\n/**\n * Get the the target text node to update or create one from of a comment node\n * @param   {HTMLElement} node - any html element containing childNodes\n * @param   {number} childNodeIndex - index of the text node in the childNodes list\n * @returns {HTMLTextNode} the text node to update\n */\n\nconst getTextNode = (node, childNodeIndex) => {\n  const target = node.childNodes[childNodeIndex];\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode('');\n    node.replaceChild(textNode, target);\n    return textNode;\n  }\n\n  return target;\n};\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} data - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\nfunction textExpression(node, data, value) {\n  node.data = normalizeStringValue(value);\n}\n\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\nfunction valueExpression(node, expression, value) {\n  node.value = normalizeStringValue(value);\n}\n\nvar expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\n\nconst Expression = Object.seal({\n  // Static props\n  // node: null,\n  // value: null,\n  // API methods\n\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope); // IO() DOM updates\n\n    apply(this, this.value);\n    return this;\n  },\n\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this;\n  },\n\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    // unmount only the event handling expressions\n    if (this.type === EVENT) apply(this, null);\n    return this;\n  }\n\n});\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\n\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value);\n}\n\nfunction create$2(node, data) {\n  return Object.assign({}, Expression, data, {\n    node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node\n  });\n}\n\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return Object.assign({}, acc, {\n      [method]: scope => {\n        return collection.map(item => item[method](scope)) && context;\n      }\n    });\n  }, {});\n}\n\nfunction create$3(node, _ref) {\n  let {\n    expressions\n  } = _ref;\n  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$2(node, expression)), ['mount', 'update', 'unmount']));\n}\n\n// Riot.js constants that can be used accross more modules\nconst COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n      DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n      PLUGINS_SET = new Set(),\n      IS_DIRECTIVE = 'is',\n      VALUE_ATTRIBUTE = 'value',\n      MOUNT_METHOD_KEY = 'mount',\n      UPDATE_METHOD_KEY = 'update',\n      UNMOUNT_METHOD_KEY = 'unmount',\n      SHOULD_UPDATE_KEY = 'shouldUpdate',\n      ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n      ON_MOUNTED_KEY = 'onMounted',\n      ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n      ON_UPDATED_KEY = 'onUpdated',\n      ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n      ON_UNMOUNTED_KEY = 'onUnmounted',\n      PROPS_KEY = 'props',\n      STATE_KEY = 'state',\n      SLOTS_KEY = 'slots',\n      ROOT_KEY = 'root',\n      IS_PURE_SYMBOL = Symbol.for('pure'),\n      PARENT_KEY_SYMBOL = Symbol('parent'),\n      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n      TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nvar globals = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP,\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY,\n  PLUGINS_SET: PLUGINS_SET,\n  IS_DIRECTIVE: IS_DIRECTIVE,\n  VALUE_ATTRIBUTE: VALUE_ATTRIBUTE,\n  MOUNT_METHOD_KEY: MOUNT_METHOD_KEY,\n  UPDATE_METHOD_KEY: UPDATE_METHOD_KEY,\n  UNMOUNT_METHOD_KEY: UNMOUNT_METHOD_KEY,\n  SHOULD_UPDATE_KEY: SHOULD_UPDATE_KEY,\n  ON_BEFORE_MOUNT_KEY: ON_BEFORE_MOUNT_KEY,\n  ON_MOUNTED_KEY: ON_MOUNTED_KEY,\n  ON_BEFORE_UPDATE_KEY: ON_BEFORE_UPDATE_KEY,\n  ON_UPDATED_KEY: ON_UPDATED_KEY,\n  ON_BEFORE_UNMOUNT_KEY: ON_BEFORE_UNMOUNT_KEY,\n  ON_UNMOUNTED_KEY: ON_UNMOUNTED_KEY,\n  PROPS_KEY: PROPS_KEY,\n  STATE_KEY: STATE_KEY,\n  SLOTS_KEY: SLOTS_KEY,\n  ROOT_KEY: ROOT_KEY,\n  IS_PURE_SYMBOL: IS_PURE_SYMBOL,\n  PARENT_KEY_SYMBOL: PARENT_KEY_SYMBOL,\n  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,\n  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL\n});\n\nfunction extendParentScope(attributes, scope, parentScope) {\n  if (!attributes || !attributes.length) return parentScope;\n  const expressions = attributes.map(attr => Object.assign({}, attr, {\n    value: attr.evaluate(scope)\n  }));\n  return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions));\n} // this function is only meant to fix an edge case\n// https://github.com/riot/riot/issues/2842\n\n\nconst getRealParent = (scope, parentScope) => parentScope ? parentScope === scope ? scope[PARENT_KEY_SYMBOL] : parentScope : undefined;\n\nconst SlotBinding = Object.seal({\n  // dynamic binding properties\n  // node: null,\n  // name: null,\n  attributes: [],\n\n  // template: null,\n  getTemplateScope(scope, parentScope) {\n    return extendParentScope(this.attributes, scope, parentScope);\n  },\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find((_ref) => {\n      let {\n        id\n      } = _ref;\n      return id === this.name;\n    }) : false;\n    const {\n      parentNode\n    } = this.node;\n    const realParent = getRealParent(scope, parentScope);\n    this.template = templateData && create$6(templateData.html, templateData.bindings).createDOM(parentNode);\n\n    if (this.template) {\n      this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);\n      this.template.children = moveSlotInnerContent(this.node);\n    }\n\n    removeNode(this.node);\n    return this;\n  },\n\n  update(scope, parentScope) {\n    if (this.template) {\n      const realParent = getRealParent(scope, parentScope);\n      this.template.update(this.getTemplateScope(scope, realParent), realParent);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);\n    }\n\n    return this;\n  }\n\n});\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLNode} slot - slot node\n * @param   {HTMLElement} children - array to fill with the child nodes detected\n * @returns {HTMLElement[]} list of the node moved\n */\n\nfunction moveSlotInnerContent(slot, children) {\n  if (children === void 0) {\n    children = [];\n  }\n\n  const child = slot.firstChild;\n\n  if (child) {\n    slot.parentNode.insertBefore(child, slot);\n    return [child, ...moveSlotInnerContent(slot)];\n  }\n\n  return children;\n}\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} options.name - slot id\n * @returns {Object} Slot binding object\n */\n\n\nfunction createSlot(node, _ref2) {\n  let {\n    name,\n    attributes\n  } = _ref2;\n  return Object.assign({}, SlotBinding, {\n    attributes,\n    node,\n    name\n  });\n}\n\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\n\nfunction getTag(component, slots, attributes) {\n  if (slots === void 0) {\n    slots = [];\n  }\n\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({\n      slots,\n      attributes\n    });\n  } // otherwise we return a template chunk\n\n\n  return create$6(slotsToMarkup(slots), [...slotBindings(slots), {\n    // the attributes should be registered as binding\n    // if we fallback to a normal template chunk\n    expressions: attributes.map(attr => {\n      return Object.assign({\n        type: ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\n\n\nfunction slotBindings(slots) {\n  return slots.reduce((acc, _ref) => {\n    let {\n      bindings\n    } = _ref;\n    return acc.concat(bindings);\n  }, []);\n}\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\n\n\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html;\n  }, '');\n}\n\nconst TagBinding = Object.seal({\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // name: null,\n  // slots: null,\n  // tag: null,\n  // attributes: null,\n  // getComponent: null,\n  mount(scope) {\n    return this.update(scope);\n  },\n\n  update(scope, parentScope) {\n    const name = this.evaluate(scope); // simple update\n\n    if (name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true); // mount the new tag\n\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag);\n    }\n\n    return this;\n  }\n\n});\nfunction create$4(node, _ref2) {\n  let {\n    evaluate,\n    getComponent,\n    slots,\n    attributes\n  } = _ref2;\n  return Object.assign({}, TagBinding, {\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  });\n}\n\nvar bindings = {\n  [IF]: create$1,\n  [SIMPLE]: create$3,\n  [EACH]: create,\n  [TAG]: create$4,\n  [SLOT]: createSlot\n};\n\n/**\n * Text expressions in a template tag will get childNodeIndex value normalized\n * depending on the position of the <template> tag offset\n * @param   {Expression[]} expressions - riot expressions array\n * @param   {number} textExpressionsOffset - offset of the <template> tag\n * @returns {Expression[]} expressions containing the text expressions normalized\n */\n\nfunction fixTextExpressionsOffset(expressions, textExpressionsOffset) {\n  return expressions.map(e => e.type === TEXT ? Object.assign({}, e, {\n    childNodeIndex: e.childNodeIndex + textExpressionsOffset\n  }) : e);\n}\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {Object} binding - binding data\n * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset\n * @returns {Binding} Binding object\n */\n\n\nfunction create$5(root, binding, templateTagOffset) {\n  const {\n    selector,\n    type,\n    redundantAttribute,\n    expressions\n  } = binding; // find the node to apply the bindings\n\n  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node\n\n  if (redundantAttribute) node.removeAttribute(redundantAttribute);\n  const bindingExpressions = expressions || []; // init the binding\n\n  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {\n    expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions\n  }));\n}\n\nfunction createHTMLTree(html, root) {\n  const template = isTemplate(root) ? root : document.createElement('template');\n  template.innerHTML = html;\n  return template.content;\n} // for svg nodes we need a bit more work\n\n\nfunction createSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`, 'application/xml').documentElement, true);\n  return svgNode;\n}\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\n\n\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return createSVGTree(html, root);\n  return createHTMLTree(html, root);\n}\n\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {HTMLFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\n\nfunction injectDOM(el, dom) {\n  switch (true) {\n    case isSvg(el):\n      moveChildren(dom, el);\n      break;\n\n    case isTemplate(el):\n      el.parentNode.replaceChild(dom, el);\n      break;\n\n    default:\n      el.appendChild(dom);\n  }\n}\n\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string} html - markup that will be injected into the root node\n * @returns {HTMLFragment} fragment that will be injected into the root node\n */\n\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);\n}\n/**\n * Template Chunk model\n * @type {Object}\n */\n\n\nconst TemplateChunk = Object.freeze({\n  // Static props\n  // bindings: null,\n  // bindingsData: null,\n  // html: null,\n  // isTemplateTag: false,\n  // fragment: null,\n  // children: null,\n  // dom: null,\n  // el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html);\n    return this;\n  },\n\n  // API methods\n\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta) {\n    if (meta === void 0) {\n      meta = {};\n    }\n\n    if (!el) throw new Error('Please provide DOM node to mount properly your template');\n    if (this.el) this.unmount(scope); // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n\n    const {\n      fragment,\n      children,\n      avoidDOMInjection\n    } = meta; // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n\n    const {\n      parentNode\n    } = children ? children[0] : el;\n    const isTemplateTag = isTemplate(el);\n    const templateTagOffset = isTemplateTag ? Math.max(Array.from(parentNode.childNodes).indexOf(el), 0) : null;\n    this.isTemplateTag = isTemplateTag; // create the DOM if it wasn't created before\n\n    this.createDOM(el);\n\n    if (this.dom) {\n      // create the new template dom fragment if it want already passed in via meta\n      this.fragment = fragment || this.dom.cloneNode(true);\n    } // store root node\n    // notice that for template tags the root note will be the parent tag\n\n\n    this.el = this.isTemplateTag ? parentNode : el; // create the children array only for the <template> fragments\n\n    this.children = this.isTemplateTag ? children || Array.from(this.fragment.childNodes) : null; // inject the DOM into the el only if a fragment is available\n\n    if (!avoidDOMInjection && this.fragment) injectDOM(el, this.fragment); // create the bindings\n\n    this.bindings = this.bindingsData.map(binding => create$5(this.el, binding, templateTagOffset));\n    this.bindings.forEach(b => b.mount(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.el) {\n      this.bindings.forEach(b => b.unmount(scope, parentScope, mustRemoveRoot));\n\n      switch (true) {\n        // <template> tags should be treated a bit differently\n        // we need to clear their children only if it's explicitly required by the caller\n        // via mustRemoveRoot !== null\n        case this.children && mustRemoveRoot !== null:\n          clearChildren(this.children);\n          break;\n        // remove the root node only if the mustRemoveRoot === true\n\n        case mustRemoveRoot === true:\n          removeNode(this.el);\n          break;\n        // otherwise we clean the node children\n\n        case mustRemoveRoot !== null:\n          cleanNode(this.el);\n          break;\n      }\n\n      this.el = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return Object.assign({}, this, {\n      el: null\n    });\n  }\n\n});\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {Array} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\n\nfunction create$6(html, bindings) {\n  if (bindings === void 0) {\n    bindings = [];\n  }\n\n  return Object.assign({}, TemplateChunk, {\n    html,\n    bindingsData: bindings\n  });\n}\n\n/**\n * Method used to bind expressions to a DOM node\n * @param   {string|HTMLElement} html - your static template html structure\n * @param   {Array} bindings - list of the expressions to bind to update the markup\n * @returns {TemplateChunk} a new TemplateChunk object having the `update`,`mount`, `unmount` and `clone` methods\n *\n * @example\n *\n * riotDOMBindings\n *  .template(\n *   `<div expr0><!----></div><div><p expr1><!----><section expr2></section></p>`,\n *   [\n *     {\n *       selector: '[expr0]',\n *       redundantAttribute: 'expr0',\n *       expressions: [\n *         {\n *           type: expressionTypes.TEXT,\n *           childNodeIndex: 0,\n *           evaluate(scope) {\n *             return scope.time;\n *           },\n *         },\n *       ],\n *     },\n *     {\n *       selector: '[expr1]',\n *       redundantAttribute: 'expr1',\n *       expressions: [\n *         {\n *           type: expressionTypes.TEXT,\n *           childNodeIndex: 0,\n *           evaluate(scope) {\n *             return scope.name;\n *           },\n *         },\n *         {\n *           type: 'attribute',\n *           name: 'style',\n *           evaluate(scope) {\n *             return scope.style;\n *           },\n *         },\n *       ],\n *     },\n *     {\n *       selector: '[expr2]',\n *       redundantAttribute: 'expr2',\n *       type: bindingTypes.IF,\n *       evaluate(scope) {\n *         return scope.isVisible;\n *       },\n *       template: riotDOMBindings.template('hello there'),\n *     },\n *   ]\n * )\n */\n\nvar DOMBindings = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  template: create$6,\n  createBinding: create$5,\n  createExpression: create$2,\n  bindingTypes: bindingTypes,\n  expressionTypes: expressionTypes\n});\n\nfunction noop() {\n  return this;\n}\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\n\nfunction autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source);\n  });\n  return source;\n}\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\n\nfunction callOrAssign(source) {\n  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;\n}\n\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\nfunction defineProperty(source, key, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, Object.assign({\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source;\n}\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\n\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach((_ref) => {\n    let [key, value] = _ref;\n    defineProperty(source, key, value, options);\n  });\n  return source;\n}\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\n\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach((_ref2) => {\n    let [key, value] = _ref2;\n    if (!source[key]) source[key] = value;\n  });\n  return source;\n}\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  } // this object could be looped out of the box\n\n\n  return els;\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\n\nfunction $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);\n}\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\n\nconst normalize = values => values.length === 1 ? values[0] : values;\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\n\n\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\n\n\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : {\n    [name]: value\n  };\n  const props = Object.keys(attrs);\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els;\n}\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\n\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute');\n}\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nvar cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn) {\n  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    acc[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args = [...acc, ...args];\n    return args.length < fn.length ? curry(fn, ...args) : fn(...args);\n  };\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\nconst COMPONENT_CORE_HELPERS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\nconst PURE_COMPONENT_API = Object.freeze({\n  [MOUNT_METHOD_KEY]: noop,\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY]: noop\n});\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  [SHOULD_UPDATE_KEY]: noop,\n  [ON_BEFORE_MOUNT_KEY]: noop,\n  [ON_MOUNTED_KEY]: noop,\n  [ON_BEFORE_UPDATE_KEY]: noop,\n  [ON_UPDATED_KEY]: noop,\n  [ON_BEFORE_UNMOUNT_KEY]: noop,\n  [ON_UNMOUNTED_KEY]: noop\n});\nconst MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {\n  clone: noop,\n  createDOM: noop\n});\n/**\n * Evaluate the component properties either from its real attributes or from its initial user properties\n * @param   {HTMLElement} element - component root\n * @param   {Object}  initialProps - initial props\n * @returns {Object} component props key value pairs\n */\n\nfunction evaluateInitialProps(element, initialProps) {\n  if (initialProps === void 0) {\n    initialProps = {};\n  }\n\n  return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));\n}\n/**\n * Bind a DOM node to its component object\n * @param   {HTMLElement} node - html node mounted\n * @param   {Object} component - Riot.js component object\n * @returns {Object} the component object received as second argument\n */\n\n\nconst bindDOMNodeToComponentObject = (node, component) => node[DOM_COMPONENT_INSTANCE_PROPERTY] = component;\n/**\n * Wrap the Riot.js core API methods using a mapping function\n * @param   {Function} mapFunction - lifting function\n * @returns {Object} an object having the { mount, update, unmount } functions\n */\n\n\nfunction createCoreAPIMethods(mapFunction) {\n  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {\n    acc[method] = mapFunction(method);\n    return acc;\n  }, {});\n}\n/**\n * Factory function to create the component templates only once\n * @param   {Function} template - component template creation function\n * @param   {Object} components - object containing the nested components\n * @returns {TemplateChunk} template chunk object\n */\n\n\nfunction componentTemplateFactory(template, components) {\n  return template(create$6, expressionTypes, bindingTypes, name => {\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name);\n  });\n}\n/**\n * Create a pure component\n * @param   {Function} pureFactoryFunction - pure component factory function\n * @param   {Array} options.slots - component slots\n * @param   {Array} options.attributes - component attributes\n * @param   {Array} options.template - template factory function\n * @param   {Array} options.template - template factory function\n * @param   {any} options.props - initial component properties\n * @returns {Object} pure component object\n */\n\n\nfunction createPureComponent(pureFactoryFunction, _ref) {\n  let {\n    slots,\n    attributes,\n    props,\n    css,\n    template\n  } = _ref;\n  if (template) panic('Pure components can not have html');\n  if (css) panic('Pure components do not have css');\n  const component = defineDefaults(pureFactoryFunction({\n    slots,\n    attributes,\n    props\n  }), PURE_COMPONENT_API);\n  return createCoreAPIMethods(method => function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // intercept the mount calls to bind the DOM node to the pure object created\n    // see also https://github.com/riot/riot/issues/2806\n    if (method === MOUNT_METHOD_KEY) {\n      const [el] = args;\n      bindDOMNodeToComponentObject(el, component);\n    }\n\n    component[method](...args);\n    return component;\n  });\n}\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {string} options.css - component css\n * @param   {Function} options.template - functon that will return the dom-bindings template function\n * @param   {Object} options.exports - component interface\n * @param   {string} options.name - component name\n * @returns {Object} component like interface\n */\n\n\nfunction createComponent(_ref2) {\n  let {\n    css,\n    template,\n    exports,\n    name\n  } = _ref2;\n  const templateFn = template ? componentTemplateFactory(template, exports ? createSubcomponents(exports.components) : {}) : MOCKED_TEMPLATE_INTERFACE;\n  return (_ref3) => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref3;\n    // pure components rendering will be managed by the end user\n    if (exports && exports[IS_PURE_SYMBOL]) return createPureComponent(exports, {\n      slots,\n      attributes,\n      props,\n      css,\n      template\n    });\n    const componentAPI = callOrAssign(exports) || {};\n    const component = defineComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components create via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Component definition function\n * @param   {Object} implementation - the componen implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction defineComponent(_ref4) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref4;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    [STATE_KEY]: {}\n  })), Object.assign({\n    // defined during the component creation\n    [SLOTS_KEY]: null,\n    [ROOT_KEY]: null\n  }, COMPONENT_CORE_HELPERS, {\n    name,\n    css,\n    template\n  })));\n}\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  const expressions = attributes.map(a => create$2(node, a));\n  const binding = {};\n  return Object.assign(binding, Object.assign({\n    expressions\n  }, createCoreAPIMethods(method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  })));\n}\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\n\nfunction createSubcomponents(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref5) => {\n    let [key, value] = _ref5;\n    acc[camelToDashCase(key)] = createComponent(value);\n    return acc;\n  }, {});\n}\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component);\n}\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state givent to the `update` call\n * @returns {Object} new object state\n */\n\n\nfunction computeState(oldState, newState) {\n  return Object.assign({}, oldState, callOrAssign(newState));\n}\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, IS_DIRECTIVE, name);\n  }\n}\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\n\nfunction enhanceComponentAPI(component, _ref6) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref6;\n  return autobindMethods(runPlugins(defineProperties(Object.create(component), {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, evaluateInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node\n\n      bindDOMNodeToComponentObject(element, this); // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, ROOT_KEY, element); // define the slots array\n\n      defineProperty(this, SLOTS_KEY, slots); // before mount lifecycle event\n\n      this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[PARENT_KEY_SYMBOL] = parentScope; // mount the template\n\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      if (parentScope) {\n        this[PARENT_KEY_SYMBOL] = parentScope;\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false) return;\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);\n      this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount(); // if the preserveRoot is null the template html will be left untouched\n      // in that case the DOM cleanup will happen differently from a parent node\n\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);\n      this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({\n    props: initialProps\n  });\n  return component.mount(element);\n}\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nconst {\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,\n  PLUGINS_SET: PLUGINS_SET$1\n} = globals;\n/**\n * Riot public api\n */\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.set(name, createComponent({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\n\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of nodes upgraded\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {boolean|null} keepRootElement - if true keep the root element\n * @returns {Array} list of nodes unmounted\n */\n\nfunction unmount(selector, keepRootElement) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY$1]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY$1].unmount(keepRootElement);\n    }\n\n    return element;\n  });\n}\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET$1.has(plugin)) panic('This plugin was already installed');\n  PLUGINS_SET$1.add(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET$1.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET$1.delete(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Helper method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\n\nfunction component(implementation) {\n  return function (el, props, _temp) {\n    let {\n      slots,\n      attributes,\n      parentScope\n    } = _temp === void 0 ? {} : _temp;\n    return compose(c => c.mount(el, parentScope), c => c({\n      props,\n      slots,\n      attributes\n    }), createComponent)(implementation);\n  };\n}\n/**\n * Lift a riot component Interface into a pure riot object\n * @param   {Function} func - RiotPureComponent factory function\n * @returns {Function} the lifted original function received as argument\n */\n\nfunction pure(func) {\n  if (!isFunction(func)) panic('riot.pure accepts only arguments of type \"function\"');\n  func[IS_PURE_SYMBOL] = true;\n  return func;\n}\n/** @type {string} current riot version */\n\nconst version = 'v4.13.4'; // expose some internal stuff that might be used from external tools\n\nconst __ = {\n  cssManager,\n  DOMBindings,\n  createComponent,\n  defineComponent,\n  globals\n};\n\nexport { __, component, install, mount, pure, register, uninstall, unmount, unregister, version };\n","import App from './App.riot'\nimport {component} from 'riot'\n\ncomponent(App)(document.querySelector('#root'), {\n  message: 'Hello there'\n})","var bundleURL = null;\nfunction getBundleURLCached() {\n  if (!bundleURL) {\n    bundleURL = getBundleURL();\n  }\n\n  return bundleURL;\n}\n\nfunction getBundleURL() {\n  // Attempt to find the URL of the current script and use that as the base URL\n  try {\n    throw new Error;\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      return getBaseURL(matches[0]);\n    }\n  }\n\n  return '/';\n}\n\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n}\n\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\n","var getBundleURL = require('./bundle-url').getBundleURL;\n\nfunction loadBundlesLazy(bundles) {\n  if (!Array.isArray(bundles)) {\n    bundles = [bundles]\n  }\n\n  var id = bundles[bundles.length - 1];\n\n  try {\n    return Promise.resolve(require(id));\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      return new LazyPromise(function (resolve, reject) {\n        loadBundles(bundles.slice(0, -1))\n          .then(function () {\n            return require(id);\n          })\n          .then(resolve, reject);\n      });\n    }\n\n    throw err;\n  }\n}\n\nfunction loadBundles(bundles) {\n  return Promise.all(bundles.map(loadBundle));\n}\n\nvar bundleLoaders = {};\nfunction registerBundleLoader(type, loader) {\n  bundleLoaders[type] = loader;\n}\n\nmodule.exports = exports = loadBundlesLazy;\nexports.load = loadBundles;\nexports.register = registerBundleLoader;\n\nvar bundles = {};\nfunction loadBundle(bundle) {\n  var id;\n  if (Array.isArray(bundle)) {\n    id = bundle[1];\n    bundle = bundle[0];\n  }\n\n  if (bundles[bundle]) {\n    return bundles[bundle];\n  }\n\n  var type = (bundle.substring(bundle.lastIndexOf('.') + 1, bundle.length) || bundle).toLowerCase();\n  var bundleLoader = bundleLoaders[type];\n  if (bundleLoader) {\n    return bundles[bundle] = bundleLoader(getBundleURL() + bundle)\n      .then(function (resolved) {\n        if (resolved) {\n          module.bundle.register(id, resolved);\n        }\n\n        return resolved;\n      }).catch(function(e) {\n        delete bundles[bundle];\n        \n        throw e;\n      });\n  }\n}\n\nfunction LazyPromise(executor) {\n  this.executor = executor;\n  this.promise = null;\n}\n\nLazyPromise.prototype.then = function (onSuccess, onError) {\n  if (this.promise === null) this.promise = new Promise(this.executor)\n  return this.promise.then(onSuccess, onError)\n};\n\nLazyPromise.prototype.catch = function (onError) {\n  if (this.promise === null) this.promise = new Promise(this.executor)\n  return this.promise.catch(onError)\n};\n","module.exports = function loadWASMBundle(bundle) {\n  return fetch(bundle)\n    .then(function (res) {\n      if (WebAssembly.instantiateStreaming) {\n        return WebAssembly.instantiateStreaming(res);\n      } else {\n        return res.arrayBuffer()\n          .then(function (data) {\n            return WebAssembly.instantiate(data);\n          });\n      }\n    })\n    .then(function (wasmModule) {\n      return wasmModule.instance.exports;\n    });\n};\n"]}
{"version":3,"sources":["../src/App.riot","../node_modules/riot/riot.esm.js","../src/index.js"],"names":["template","expressionTypes","bindingTypes","getComponent","TEXT","scope","props","message","camelToDashCase","string","replace","toLowerCase","dashToCamelCase","_","c","toUpperCase","DOMattributesToObject","element","Array","from","attributes","reduce","acc","attribute","name","value","moveChildren","source","target","firstChild","appendChild","cleanNode","node","clearChildren","childNodes","children","forEach","removeNode","parentNode","remove","removeChild","EACH","IF","SIMPLE","TAG","SLOT","ATTRIBUTE","EVENT","VALUE","createTemplateMeta","componentTemplate","fragment","dom","cloneNode","avoidDOMInjection","indexOf","slice","append","get","parent","start","end","before","isSelect","noSelection","child","insertBefore","selected","selectedIndex","call","querySelectorAll","eqeq","a","b","identity","O","indexOf$1","moreNodes","moreStart","moreEnd","lessNodes","lessStart","lessEnd","compare","length","m","l","isReversed","futureNodes","futureEnd","currentNodes","currentStart","currentEnd","next","list","i","nextSibling","drop","DELETION","INSERTION","SKIP","SKIP_OND","HS","futureStart","futureChanges","currentChanges","k","minLen","link","tresh","nodes","index","idxInOld","findK","newi","oldi","prev","diff","ptr","OND","rows","cols","d","r","pv","cv","pd","v","outer","diffIdx","applyDiff","currentLength","live","currentIndex","push","ktr","j","lo","hi","mid","smartDiff","dropChild","domdiff","options","currentSame","futureSame","checkType","type","isSvg","el","owner","ownerSVGElement","isTemplate","isNil","content","isFunction","isBoolean","isObject","UNMOUNT_SCOPE","Symbol","EachBinding","Object","seal","mount","parentScope","update","placeholder","childrenMap","collection","evaluate","items","createPatch","newChildrenMap","batches","patch","values","fn","unmount","redundant","item","info","pop","context","mustFilterItem","condition","Boolean","extendScope","_ref","itemName","indexName","binding","getKey","root","isTemplateTag","Map","create","key","oldItem","clone","mustMount","meta","delete","set","_ref2","document","createTextNode","assign","createDOM","IfBinding","pristine","mustUnmount","create$1","panic","Error","memoize","cache","cached","val","has","evaluateAttributeExpressions","REMOVE_ATTRIBUTE","SET_ATTIBUTE","ElementProto","Element","prototype","isNativeHtmlProperty","hasOwnProperty","setAllAttributes","entries","attributeExpression","removeAllAttributes","newAttributes","oldAttributes","newKeys","keys","filter","includes","removeAttribute","oldValue","getMethod","normalizeValue","RE_EVENTS_PREFIX","getCallbackAndOptions","isArray","EventListener","handleEvent","event","ListenersWeakMap","WeakMap","createListener","listener","eventExpression","normalizedEventName","eventListener","callback","handler","mustAddEvent","removeEventListener","addEventListener","normalizeStringValue","getTextNode","childNodeIndex","nodeType","Node","COMMENT_NODE","textNode","replaceChild","textExpression","data","valueExpression","expression","expressions","Expression","apply","create$2","flattenCollectionMethods","methods","method","map","create$3","COMPONENTS_IMPLEMENTATION_MAP","DOM_COMPONENT_INSTANCE_PROPERTY","PLUGINS_SET","Set","IS_DIRECTIVE","VALUE_ATTRIBUTE","MOUNT_METHOD_KEY","UPDATE_METHOD_KEY","UNMOUNT_METHOD_KEY","SHOULD_UPDATE_KEY","ON_BEFORE_MOUNT_KEY","ON_MOUNTED_KEY","ON_BEFORE_UPDATE_KEY","ON_UPDATED_KEY","ON_BEFORE_UNMOUNT_KEY","ON_UNMOUNTED_KEY","PROPS_KEY","STATE_KEY","SLOTS_KEY","ROOT_KEY","IS_PURE_SYMBOL","for","PARENT_KEY_SYMBOL","ATTRIBUTES_KEY_SYMBOL","TEMPLATE_KEY_SYMBOL","globals","freeze","__proto__","extendParentScope","attr","getRealParent","undefined","SlotBinding","getTemplateScope","templateData","slots","find","id","realParent","create$6","html","bindings","moveSlotInnerContent","mustRemoveRoot","slot","createSlot","getTag","component","slotsToMarkup","slotBindings","concat","TagBinding","tag","keepRootTag","create$4","fixTextExpressionsOffset","textExpressionsOffset","e","create$5","templateTagOffset","selector","redundantAttribute","querySelector","bindingExpressions","createHTMLTree","createElement","innerHTML","createSVGTree","container","svgNode","ownerDocument","importNode","window","DOMParser","parseFromString","documentElement","createDOMTree","injectDOM","createTemplateDOM","TemplateChunk","Math","max","bindingsData","DOMBindings","createBinding","createExpression","noop","autobindMethods","bind","callOrAssign","constructor","defineProperty","enumerable","writable","configurable","defineProperties","properties","defineDefaults","defaults","domToArray","els","test","toString","$","ctx","normalize","parseNodes","names","n","attrs","prop","setAttribute","CSS_BY_NAME","STYLE_NODE_SELECTOR","getStyleNode","style","head","cssManager","add","css","inject","join","curry","_len","arguments","_key","_len2","args","_key2","getName","tagName","COMPONENT_CORE_HELPERS","$$","PURE_COMPONENT_API","COMPONENT_LIFECYCLE_METHODS","MOCKED_TEMPLATE_INTERFACE","evaluateInitialProps","initialProps","bindDOMNodeToComponentObject","createCoreAPIMethods","mapFunction","componentTemplateFactory","components","createPureComponent","pureFactoryFunction","createComponent","exports","templateFn","createSubcomponents","_ref3","componentAPI","defineComponent","state","preserveRoot","_ref4","enhanceComponentAPI","createAttributeBindings","_ref5","runPlugins","computeState","oldState","newState","addCssHook","_ref6","newProps","mountComponent","componentName","compose","fns","f","g","DOM_COMPONENT_INSTANCE_PROPERTY$1","COMPONENTS_IMPLEMENTATION_MAP$1","PLUGINS_SET$1","register","unregister","keepRootElement","install","plugin","uninstall","implementation","_temp","pure","func","version","__","App"],"mappings":"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","file":"src.c6e97bee.js","sourceRoot":"../public","sourcesContent":["export default {\n  'css': null,\n  'exports': null,\n\n  'template': function(template, expressionTypes, bindingTypes, getComponent) {\n    return template('<p expr0=\"expr0\"> </p>', [{\n      'redundantAttribute': 'expr0',\n      'selector': '[expr0]',\n\n      'expressions': [{\n        'type': expressionTypes.TEXT,\n        'childNodeIndex': 0,\n\n        'evaluate': function(scope) {\n          return scope.props.message;\n        }\n      }]\n    }]);\n  },\n\n  'name': 'app'\n};","/* Riot v4.13.4, @license MIT */\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\n\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value;\n    return acc;\n  }, {});\n}\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\n// Ignore this helper because it's needed only for svg tags\n\nfunction moveChildren(source, target) {\n  if (source.firstChild) {\n    target.appendChild(source.firstChild);\n    moveChildren(source, target);\n  }\n}\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\n\nfunction cleanNode(node) {\n  clearChildren(node.childNodes);\n}\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\n\nfunction clearChildren(children) {\n  Array.from(children).forEach(removeNode);\n}\n/**\n * Remove a node from the DOM\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\n\nfunction removeNode(node) {\n  const {\n    parentNode\n  } = node;\n  if (node.remove) node.remove();\n  /* istanbul ignore else */\n  else if (parentNode) parentNode.removeChild(node);\n}\n\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\nvar bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n};\n\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nvar expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n};\n\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk\n */\nfunction createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true);\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    children: Array.from(fragment.childNodes)\n  };\n}\n\nconst {\n  indexOf,\n  slice\n} = [];\n\nconst append = (get, parent, children, start, end, before) => {\n  const isSelect = ('selectedIndex' in parent);\n  let noSelection = isSelect;\n\n  while (start < end) {\n    const child = get(children[start], 1);\n    parent.insertBefore(child, before);\n\n    if (isSelect && noSelection && child.selected) {\n      noSelection = !noSelection;\n      let {\n        selectedIndex\n      } = parent;\n      parent.selectedIndex = selectedIndex < 0 ? start : indexOf.call(parent.querySelectorAll('option'), child);\n    }\n\n    start++;\n  }\n};\nconst eqeq = (a, b) => a == b;\nconst identity = O => O;\nconst indexOf$1 = (moreNodes, moreStart, moreEnd, lessNodes, lessStart, lessEnd, compare) => {\n  const length = lessEnd - lessStart;\n  /* istanbul ignore if */\n\n  if (length < 1) return -1;\n\n  while (moreEnd - moreStart >= length) {\n    let m = moreStart;\n    let l = lessStart;\n\n    while (m < moreEnd && l < lessEnd && compare(moreNodes[m], lessNodes[l])) {\n      m++;\n      l++;\n    }\n\n    if (l === lessEnd) return moreStart;\n    moreStart = m + 1;\n  }\n\n  return -1;\n};\nconst isReversed = (futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare) => {\n  while (currentStart < currentEnd && compare(currentNodes[currentStart], futureNodes[futureEnd - 1])) {\n    currentStart++;\n    futureEnd--;\n  }\n  return futureEnd === 0;\n};\nconst next = (get, list, i, length, before) => i < length ? get(list[i], 0) : 0 < i ? get(list[i - 1], -0).nextSibling : before;\nconst remove = (get, children, start, end) => {\n  while (start < end) drop(get(children[start++], -1));\n}; // - - - - - - - - - - - - - - - - - - -\n// diff related constants and utilities\n// - - - - - - - - - - - - - - - - - - -\n\nconst DELETION = -1;\nconst INSERTION = 1;\nconst SKIP = 0;\nconst SKIP_OND = 50;\n\nconst HS = (futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges) => {\n  let k = 0;\n  /* istanbul ignore next */\n\n  let minLen = futureChanges < currentChanges ? futureChanges : currentChanges;\n  const link = Array(minLen++);\n  const tresh = Array(minLen);\n  tresh[0] = -1;\n\n  for (let i = 1; i < minLen; i++) tresh[i] = currentEnd;\n\n  const nodes = currentNodes.slice(currentStart, currentEnd);\n\n  for (let i = futureStart; i < futureEnd; i++) {\n    const index = nodes.indexOf(futureNodes[i]);\n\n    if (-1 < index) {\n      const idxInOld = index + currentStart;\n      k = findK(tresh, minLen, idxInOld);\n      /* istanbul ignore else */\n\n      if (-1 < k) {\n        tresh[k] = idxInOld;\n        link[k] = {\n          newi: i,\n          oldi: idxInOld,\n          prev: link[k - 1]\n        };\n      }\n    }\n  }\n\n  k = --minLen;\n  --currentEnd;\n\n  while (tresh[k] > currentEnd) --k;\n\n  minLen = currentChanges + futureChanges - k;\n  const diff = Array(minLen);\n  let ptr = link[k];\n  --futureEnd;\n\n  while (ptr) {\n    const {\n      newi,\n      oldi\n    } = ptr;\n\n    while (futureEnd > newi) {\n      diff[--minLen] = INSERTION;\n      --futureEnd;\n    }\n\n    while (currentEnd > oldi) {\n      diff[--minLen] = DELETION;\n      --currentEnd;\n    }\n\n    diff[--minLen] = SKIP;\n    --futureEnd;\n    --currentEnd;\n    ptr = ptr.prev;\n  }\n\n  while (futureEnd >= futureStart) {\n    diff[--minLen] = INSERTION;\n    --futureEnd;\n  }\n\n  while (currentEnd >= currentStart) {\n    diff[--minLen] = DELETION;\n    --currentEnd;\n  }\n\n  return diff;\n}; // this is pretty much the same petit-dom code without the delete map part\n// https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L556-L561\n\n\nconst OND = (futureNodes, futureStart, rows, currentNodes, currentStart, cols, compare) => {\n  const length = rows + cols;\n  const v = [];\n  let d, k, r, c, pv, cv, pd;\n\n  outer: for (d = 0; d <= length; d++) {\n    /* istanbul ignore if */\n    if (d > SKIP_OND) return null;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    cv = v[d] = [];\n\n    for (k = -d; k <= d; k += 2) {\n      if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n        c = pv[pd + k + 1];\n      } else {\n        c = pv[pd + k - 1] + 1;\n      }\n\n      r = c - k;\n\n      while (c < cols && r < rows && compare(currentNodes[currentStart + c], futureNodes[futureStart + r])) {\n        c++;\n        r++;\n      }\n\n      if (c === cols && r === rows) {\n        break outer;\n      }\n\n      cv[d + k] = c;\n    }\n  }\n\n  const diff = Array(d / 2 + length / 2);\n  let diffIdx = diff.length - 1;\n\n  for (d = v.length - 1; d >= 0; d--) {\n    while (c > 0 && r > 0 && compare(currentNodes[currentStart + c - 1], futureNodes[futureStart + r - 1])) {\n      // diagonal edge = equality\n      diff[diffIdx--] = SKIP;\n      c--;\n      r--;\n    }\n\n    if (!d) break;\n    pd = d - 1;\n    /* istanbul ignore next */\n\n    pv = d ? v[d - 1] : [0, 0];\n    k = c - r;\n\n    if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n      // vertical edge = insertion\n      r--;\n      diff[diffIdx--] = INSERTION;\n    } else {\n      // horizontal edge = deletion\n      c--;\n      diff[diffIdx--] = DELETION;\n    }\n  }\n\n  return diff;\n};\n\nconst applyDiff = (diff, get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before) => {\n  const live = [];\n  const length = diff.length;\n  let currentIndex = currentStart;\n  let i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        futureStart++;\n        currentIndex++;\n        break;\n\n      case INSERTION:\n        // TODO: bulk appends for sequential nodes\n        live.push(futureNodes[futureStart]);\n        append(get, parentNode, futureNodes, futureStart++, futureStart, currentIndex < currentLength ? get(currentNodes[currentIndex], 0) : before);\n        break;\n\n      case DELETION:\n        currentIndex++;\n        break;\n    }\n  }\n\n  i = 0;\n\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        currentStart++;\n        break;\n\n      case DELETION:\n        // TODO: bulk removes for sequential nodes\n        if (-1 < live.indexOf(currentNodes[currentStart])) currentStart++;else remove(get, currentNodes, currentStart++, currentStart);\n        break;\n    }\n  }\n};\n\nconst findK = (ktr, length, j) => {\n  let lo = 1;\n  let hi = length;\n\n  while (lo < hi) {\n    const mid = (lo + hi) / 2 >>> 0;\n    if (j < ktr[mid]) hi = mid;else lo = mid + 1;\n  }\n\n  return lo;\n};\n\nconst smartDiff = (get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before) => {\n  applyDiff(OND(futureNodes, futureStart, futureChanges, currentNodes, currentStart, currentChanges, compare) || HS(futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges), get, parentNode, futureNodes, futureStart, currentNodes, currentStart, currentLength, before);\n};\n\nconst drop = node => (node.remove || dropChild).call(node);\n\nfunction dropChild() {\n  const {\n    parentNode\n  } = this;\n  /* istanbul ignore else */\n\n  if (parentNode) parentNode.removeChild(this);\n}\n\n/*! (c) 2018 Andrea Giammarchi (ISC) */\n\nconst domdiff = (parentNode, // where changes happen\ncurrentNodes, // Array of current items/nodes\nfutureNodes, // Array of future items/nodes\noptions // optional object with one of the following properties\n//  before: domNode\n//  compare(generic, generic) => true if same generic\n//  node(generic) => Node\n) => {\n  if (!options) options = {};\n  const compare = options.compare || eqeq;\n  const get = options.node || identity;\n  const before = options.before == null ? null : get(options.before, 0);\n  const currentLength = currentNodes.length;\n  let currentEnd = currentLength;\n  let currentStart = 0;\n  let futureEnd = futureNodes.length;\n  let futureStart = 0; // common prefix\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentStart], futureNodes[futureStart])) {\n    currentStart++;\n    futureStart++;\n  } // common suffix\n\n\n  while (currentStart < currentEnd && futureStart < futureEnd && compare(currentNodes[currentEnd - 1], futureNodes[futureEnd - 1])) {\n    currentEnd--;\n    futureEnd--;\n  }\n\n  const currentSame = currentStart === currentEnd;\n  const futureSame = futureStart === futureEnd; // same list\n\n  if (currentSame && futureSame) return futureNodes; // only stuff to add\n\n  if (currentSame && futureStart < futureEnd) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentStart, currentLength, before));\n    return futureNodes;\n  } // only stuff to remove\n\n\n  if (futureSame && currentStart < currentEnd) {\n    remove(get, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  }\n\n  const currentChanges = currentEnd - currentStart;\n  const futureChanges = futureEnd - futureStart;\n  let i = -1; // 2 simple indels: the shortest sequence is a subsequence of the longest\n\n  if (currentChanges < futureChanges) {\n    i = indexOf$1(futureNodes, futureStart, futureEnd, currentNodes, currentStart, currentEnd, compare); // inner diff\n\n    if (-1 < i) {\n      append(get, parentNode, futureNodes, futureStart, i, get(currentNodes[currentStart], 0));\n      append(get, parentNode, futureNodes, i + currentChanges, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n      return futureNodes;\n    }\n  }\n  /* istanbul ignore else */\n  else if (futureChanges < currentChanges) {\n      i = indexOf$1(currentNodes, currentStart, currentEnd, futureNodes, futureStart, futureEnd, compare); // outer diff\n\n      if (-1 < i) {\n        remove(get, currentNodes, currentStart, i);\n        remove(get, currentNodes, i + futureChanges, currentEnd);\n        return futureNodes;\n      }\n    } // common case with one replacement for many nodes\n  // or many nodes replaced for a single one\n\n  /* istanbul ignore else */\n\n\n  if (currentChanges < 2 || futureChanges < 2) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, get(currentNodes[currentStart], 0));\n    remove(get, currentNodes, currentStart, currentEnd);\n    return futureNodes;\n  } // the half match diff part has been skipped in petit-dom\n  // https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L391-L397\n  // accordingly, I think it's safe to skip in here too\n  // if one day it'll come out like the speediest thing ever to do\n  // then I might add it in here too\n  // Extra: before going too fancy, what about reversed lists ?\n  //        This should bail out pretty quickly if that's not the case.\n\n\n  if (currentChanges === futureChanges && isReversed(futureNodes, futureEnd, currentNodes, currentStart, currentEnd, compare)) {\n    append(get, parentNode, futureNodes, futureStart, futureEnd, next(get, currentNodes, currentEnd, currentLength, before));\n    return futureNodes;\n  } // last resort through a smart diff\n\n\n  smartDiff(get, parentNode, futureNodes, futureStart, futureEnd, futureChanges, currentNodes, currentStart, currentEnd, currentChanges, currentLength, compare, before);\n  return futureNodes;\n};\n\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type;\n}\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\n\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n  return !!owner || owner === null;\n}\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\n\nfunction isTemplate(el) {\n  return !isNil(el.content);\n}\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\n\nfunction isFunction(value) {\n  return checkType(value, 'function');\n}\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\n\nfunction isBoolean(value) {\n  return checkType(value, 'boolean');\n}\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\n\nfunction isObject(value) {\n  return !isNil(value) && checkType(value, 'object');\n}\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\n\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\n\nconst UNMOUNT_SCOPE = Symbol('unmount');\nconst EachBinding = Object.seal({\n  // dynamic binding properties\n  // childrenMap: null,\n  // node: null,\n  // root: null,\n  // condition: null,\n  // evaluate: null,\n  // template: null,\n  // isTemplateTag: false,\n  nodes: [],\n\n  // getKey: null,\n  // indexName: null,\n  // itemName: null,\n  // afterPlaceholder: null,\n  // placeholder: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const {\n      placeholder,\n      nodes,\n      childrenMap\n    } = this;\n    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);\n    const items = collection ? Array.from(collection) : [];\n    const parent = placeholder.parentNode; // prepare the diffing\n\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes\n\n    domdiff(parent, nodes, futureNodes, {\n      before: placeholder,\n      node: patch(Array.from(childrenMap.values()), parentScope)\n    }); // trigger the mounts and the updates\n\n    batches.forEach(fn => fn()); // update the children map\n\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.update(UNMOUNT_SCOPE, parentScope);\n    return this;\n  }\n\n});\n/**\n * Patch the DOM while diffing\n * @param   {TemplateChunk[]} redundant - redundant tepmplate chunks\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\n\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      const element = redundant.pop();\n\n      if (element) {\n        const {\n          template,\n          context\n        } = element; // notice that we pass null as last argument because\n        // the root node and its children will be removed by domdiff\n\n        template.unmount(context, parentScope, null);\n      }\n    }\n\n    return item;\n  };\n}\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\n\n\nfunction mustFilterItem(condition, context) {\n  return condition ? Boolean(condition(context)) === false : false;\n}\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\n\n\nfunction extendScope(scope, _ref) {\n  let {\n    itemName,\n    indexName,\n    index,\n    item\n  } = _ref;\n  scope[itemName] = item;\n  if (indexName) scope[indexName] = index;\n  return scope;\n}\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EeachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\n\n\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root,\n    isTemplateTag\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n\n    if (mustFilterItem(condition, context)) {\n      return;\n    }\n\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = oldItem ? componentTemplate.el : root.cloneNode();\n    const mustMount = !oldItem;\n    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : {};\n\n    if (mustMount) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope, meta));\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    } // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n\n\n    if (isTemplateTag) {\n      const children = meta.children || componentTemplate.children;\n      futureNodes.push(...children);\n    } else {\n      futureNodes.push(el);\n    } // delete the old item from the children map\n\n\n    childrenMap.delete(key); // update the children map\n\n    newChildrenMap.set(key, {\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  };\n}\n\nfunction create(node, _ref2) {\n  let {\n    evaluate,\n    condition,\n    itemName,\n    indexName,\n    getKey,\n    template\n  } = _ref2;\n  const placeholder = document.createTextNode('');\n  const parent = node.parentNode;\n  const root = node.cloneNode();\n  parent.insertBefore(placeholder, node);\n  removeNode(node);\n  return Object.assign({}, EachBinding, {\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: isTemplate(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  });\n}\n\n/**\n * Binding responsible for the `if` directive\n */\n\nconst IfBinding = Object.seal({\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // isTemplateTag: false,\n  // placeholder: null,\n  // template: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n\n    const mount = () => {\n      const pristine = this.node.cloneNode();\n      this.placeholder.parentNode.insertBefore(pristine, this.placeholder);\n      this.template = this.template.clone();\n      this.template.mount(pristine, scope, parentScope);\n    };\n\n    switch (true) {\n      case mustMount:\n        mount();\n        break;\n\n      case mustUnmount:\n        this.unmount(scope);\n        break;\n\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope, true);\n    return this;\n  }\n\n});\nfunction create$1(node, _ref) {\n  let {\n    evaluate,\n    template\n  } = _ref;\n  const parent = node.parentNode;\n  const placeholder = document.createTextNode('');\n  parent.insertBefore(placeholder, node);\n  removeNode(node);\n  return Object.assign({}, IfBinding, {\n    node,\n    evaluate,\n    placeholder,\n    template: template.createDOM(node)\n  });\n}\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @returns { undefined } hoppla.. at this point the program should stop working\n */\n\nfunction panic(message) {\n  throw new Error(message);\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\n\nfunction memoize(fn) {\n  const cache = new Map();\n\n  const cached = val => {\n    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);\n  };\n\n  cached.cache = cache;\n  return cached;\n}\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\n\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {\n      value,\n      type\n    } = attribute;\n\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === ATTRIBUTE:\n        return Object.assign({}, acc, value);\n      // value attribute\n\n      case type === VALUE:\n        acc.value = attribute.value;\n        break;\n      // normal attributes\n\n      default:\n        acc[dashToCamelCase(attribute.name)] = attribute.value;\n    }\n\n    return acc;\n  }, {});\n}\n\nconst REMOVE_ATTRIBUTE = 'removeAttribute';\nconst SET_ATTIBUTE = 'setAttribute';\nconst ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;\nconst isNativeHtmlProperty = memoize(name => ElementProto.hasOwnProperty(name)); // eslint-disable-line\n\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\n\nfunction setAllAttributes(node, attributes) {\n  Object.entries(attributes).forEach((_ref) => {\n    let [name, value] = _ref;\n    return attributeExpression(node, {\n      name\n    }, value);\n  });\n}\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} newAttributes - object containing all the new attribute names\n * @param   {Object} oldAttributes - object containing all the old attribute names\n * @returns {undefined} sorry it's a void function :(\n */\n\n\nfunction removeAllAttributes(node, newAttributes, oldAttributes) {\n  const newKeys = newAttributes ? Object.keys(newAttributes) : [];\n  Object.keys(oldAttributes).filter(name => !newKeys.includes(name)).forEach(attribute => node.removeAttribute(attribute));\n}\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\n\n\nfunction attributeExpression(node, _ref2, value, oldValue) {\n  let {\n    name\n  } = _ref2;\n\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    if (oldValue) {\n      // remove all the old attributes\n      removeAllAttributes(node, value, oldValue);\n    } // is the value still truthy?\n\n\n    if (value) {\n      setAllAttributes(node, value);\n    }\n\n    return;\n  } // handle boolean attributes\n\n\n  if (!isNativeHtmlProperty(name) && (isBoolean(value) || isObject(value) || isFunction(value))) {\n    node[name] = value;\n  }\n\n  node[getMethod(value)](name, normalizeValue(name, value));\n}\n/**\n * Get the attribute modifier method\n * @param   {*} value - if truthy we return `setAttribute` othewise `removeAttribute`\n * @returns {string} the node attribute modifier method name\n */\n\nfunction getMethod(value) {\n  return isNil(value) || value === false || value === '' || isObject(value) || isFunction(value) ? REMOVE_ATTRIBUTE : SET_ATTIBUTE;\n}\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\n\n\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  if (value === true) return name;\n  return value;\n}\n\nconst RE_EVENTS_PREFIX = /^on/;\n\nconst getCallbackAndOptions = value => Array.isArray(value) ? value : [value, false]; // see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\n\n\nconst EventListener = {\n  handleEvent(event) {\n    this[event.type](event);\n  }\n\n};\nconst ListenersWeakMap = new WeakMap();\n\nconst createListener = node => {\n  const listener = Object.create(EventListener);\n  ListenersWeakMap.set(node, listener);\n  return listener;\n};\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {value} the callback just received\n */\n\n\nfunction eventExpression(node, _ref, value) {\n  let {\n    name\n  } = _ref;\n  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');\n  const eventListener = ListenersWeakMap.get(node) || createListener(node);\n  const [callback, options] = getCallbackAndOptions(value);\n  const handler = eventListener[normalizedEventName];\n  const mustRemoveEvent = handler && !callback;\n  const mustAddEvent = callback && !handler;\n\n  if (mustRemoveEvent) {\n    node.removeEventListener(normalizedEventName, eventListener);\n  }\n\n  if (mustAddEvent) {\n    node.addEventListener(normalizedEventName, eventListener, options);\n  }\n\n  eventListener[normalizedEventName] = callback;\n}\n\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\n\nfunction normalizeStringValue(value) {\n  return isNil(value) ? '' : value;\n}\n\n/**\n * Get the the target text node to update or create one from of a comment node\n * @param   {HTMLElement} node - any html element containing childNodes\n * @param   {number} childNodeIndex - index of the text node in the childNodes list\n * @returns {HTMLTextNode} the text node to update\n */\n\nconst getTextNode = (node, childNodeIndex) => {\n  const target = node.childNodes[childNodeIndex];\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode('');\n    node.replaceChild(textNode, target);\n    return textNode;\n  }\n\n  return target;\n};\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} data - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\nfunction textExpression(node, data, value) {\n  node.data = normalizeStringValue(value);\n}\n\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\nfunction valueExpression(node, expression, value) {\n  node.value = normalizeStringValue(value);\n}\n\nvar expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\n\nconst Expression = Object.seal({\n  // Static props\n  // node: null,\n  // value: null,\n  // API methods\n\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope); // IO() DOM updates\n\n    apply(this, this.value);\n    return this;\n  },\n\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this;\n  },\n\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    // unmount only the event handling expressions\n    if (this.type === EVENT) apply(this, null);\n    return this;\n  }\n\n});\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\n\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value);\n}\n\nfunction create$2(node, data) {\n  return Object.assign({}, Expression, data, {\n    node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node\n  });\n}\n\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return Object.assign({}, acc, {\n      [method]: scope => {\n        return collection.map(item => item[method](scope)) && context;\n      }\n    });\n  }, {});\n}\n\nfunction create$3(node, _ref) {\n  let {\n    expressions\n  } = _ref;\n  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$2(node, expression)), ['mount', 'update', 'unmount']));\n}\n\n// Riot.js constants that can be used accross more modules\nconst COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n      DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n      PLUGINS_SET = new Set(),\n      IS_DIRECTIVE = 'is',\n      VALUE_ATTRIBUTE = 'value',\n      MOUNT_METHOD_KEY = 'mount',\n      UPDATE_METHOD_KEY = 'update',\n      UNMOUNT_METHOD_KEY = 'unmount',\n      SHOULD_UPDATE_KEY = 'shouldUpdate',\n      ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n      ON_MOUNTED_KEY = 'onMounted',\n      ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n      ON_UPDATED_KEY = 'onUpdated',\n      ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n      ON_UNMOUNTED_KEY = 'onUnmounted',\n      PROPS_KEY = 'props',\n      STATE_KEY = 'state',\n      SLOTS_KEY = 'slots',\n      ROOT_KEY = 'root',\n      IS_PURE_SYMBOL = Symbol.for('pure'),\n      PARENT_KEY_SYMBOL = Symbol('parent'),\n      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n      TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nvar globals = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP,\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY,\n  PLUGINS_SET: PLUGINS_SET,\n  IS_DIRECTIVE: IS_DIRECTIVE,\n  VALUE_ATTRIBUTE: VALUE_ATTRIBUTE,\n  MOUNT_METHOD_KEY: MOUNT_METHOD_KEY,\n  UPDATE_METHOD_KEY: UPDATE_METHOD_KEY,\n  UNMOUNT_METHOD_KEY: UNMOUNT_METHOD_KEY,\n  SHOULD_UPDATE_KEY: SHOULD_UPDATE_KEY,\n  ON_BEFORE_MOUNT_KEY: ON_BEFORE_MOUNT_KEY,\n  ON_MOUNTED_KEY: ON_MOUNTED_KEY,\n  ON_BEFORE_UPDATE_KEY: ON_BEFORE_UPDATE_KEY,\n  ON_UPDATED_KEY: ON_UPDATED_KEY,\n  ON_BEFORE_UNMOUNT_KEY: ON_BEFORE_UNMOUNT_KEY,\n  ON_UNMOUNTED_KEY: ON_UNMOUNTED_KEY,\n  PROPS_KEY: PROPS_KEY,\n  STATE_KEY: STATE_KEY,\n  SLOTS_KEY: SLOTS_KEY,\n  ROOT_KEY: ROOT_KEY,\n  IS_PURE_SYMBOL: IS_PURE_SYMBOL,\n  PARENT_KEY_SYMBOL: PARENT_KEY_SYMBOL,\n  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,\n  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL\n});\n\nfunction extendParentScope(attributes, scope, parentScope) {\n  if (!attributes || !attributes.length) return parentScope;\n  const expressions = attributes.map(attr => Object.assign({}, attr, {\n    value: attr.evaluate(scope)\n  }));\n  return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions));\n} // this function is only meant to fix an edge case\n// https://github.com/riot/riot/issues/2842\n\n\nconst getRealParent = (scope, parentScope) => parentScope ? parentScope === scope ? scope[PARENT_KEY_SYMBOL] : parentScope : undefined;\n\nconst SlotBinding = Object.seal({\n  // dynamic binding properties\n  // node: null,\n  // name: null,\n  attributes: [],\n\n  // template: null,\n  getTemplateScope(scope, parentScope) {\n    return extendParentScope(this.attributes, scope, parentScope);\n  },\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find((_ref) => {\n      let {\n        id\n      } = _ref;\n      return id === this.name;\n    }) : false;\n    const {\n      parentNode\n    } = this.node;\n    const realParent = getRealParent(scope, parentScope);\n    this.template = templateData && create$6(templateData.html, templateData.bindings).createDOM(parentNode);\n\n    if (this.template) {\n      this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);\n      this.template.children = moveSlotInnerContent(this.node);\n    }\n\n    removeNode(this.node);\n    return this;\n  },\n\n  update(scope, parentScope) {\n    if (this.template) {\n      const realParent = getRealParent(scope, parentScope);\n      this.template.update(this.getTemplateScope(scope, realParent), realParent);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);\n    }\n\n    return this;\n  }\n\n});\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLNode} slot - slot node\n * @param   {HTMLElement} children - array to fill with the child nodes detected\n * @returns {HTMLElement[]} list of the node moved\n */\n\nfunction moveSlotInnerContent(slot, children) {\n  if (children === void 0) {\n    children = [];\n  }\n\n  const child = slot.firstChild;\n\n  if (child) {\n    slot.parentNode.insertBefore(child, slot);\n    return [child, ...moveSlotInnerContent(slot)];\n  }\n\n  return children;\n}\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} options.name - slot id\n * @returns {Object} Slot binding object\n */\n\n\nfunction createSlot(node, _ref2) {\n  let {\n    name,\n    attributes\n  } = _ref2;\n  return Object.assign({}, SlotBinding, {\n    attributes,\n    node,\n    name\n  });\n}\n\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\n\nfunction getTag(component, slots, attributes) {\n  if (slots === void 0) {\n    slots = [];\n  }\n\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({\n      slots,\n      attributes\n    });\n  } // otherwise we return a template chunk\n\n\n  return create$6(slotsToMarkup(slots), [...slotBindings(slots), {\n    // the attributes should be registered as binding\n    // if we fallback to a normal template chunk\n    expressions: attributes.map(attr => {\n      return Object.assign({\n        type: ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\n\n\nfunction slotBindings(slots) {\n  return slots.reduce((acc, _ref) => {\n    let {\n      bindings\n    } = _ref;\n    return acc.concat(bindings);\n  }, []);\n}\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\n\n\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html;\n  }, '');\n}\n\nconst TagBinding = Object.seal({\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // name: null,\n  // slots: null,\n  // tag: null,\n  // attributes: null,\n  // getComponent: null,\n  mount(scope) {\n    return this.update(scope);\n  },\n\n  update(scope, parentScope) {\n    const name = this.evaluate(scope); // simple update\n\n    if (name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true); // mount the new tag\n\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag);\n    }\n\n    return this;\n  }\n\n});\nfunction create$4(node, _ref2) {\n  let {\n    evaluate,\n    getComponent,\n    slots,\n    attributes\n  } = _ref2;\n  return Object.assign({}, TagBinding, {\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  });\n}\n\nvar bindings = {\n  [IF]: create$1,\n  [SIMPLE]: create$3,\n  [EACH]: create,\n  [TAG]: create$4,\n  [SLOT]: createSlot\n};\n\n/**\n * Text expressions in a template tag will get childNodeIndex value normalized\n * depending on the position of the <template> tag offset\n * @param   {Expression[]} expressions - riot expressions array\n * @param   {number} textExpressionsOffset - offset of the <template> tag\n * @returns {Expression[]} expressions containing the text expressions normalized\n */\n\nfunction fixTextExpressionsOffset(expressions, textExpressionsOffset) {\n  return expressions.map(e => e.type === TEXT ? Object.assign({}, e, {\n    childNodeIndex: e.childNodeIndex + textExpressionsOffset\n  }) : e);\n}\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {Object} binding - binding data\n * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset\n * @returns {Binding} Binding object\n */\n\n\nfunction create$5(root, binding, templateTagOffset) {\n  const {\n    selector,\n    type,\n    redundantAttribute,\n    expressions\n  } = binding; // find the node to apply the bindings\n\n  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node\n\n  if (redundantAttribute) node.removeAttribute(redundantAttribute);\n  const bindingExpressions = expressions || []; // init the binding\n\n  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {\n    expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions\n  }));\n}\n\nfunction createHTMLTree(html, root) {\n  const template = isTemplate(root) ? root : document.createElement('template');\n  template.innerHTML = html;\n  return template.content;\n} // for svg nodes we need a bit more work\n\n\nfunction createSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`, 'application/xml').documentElement, true);\n  return svgNode;\n}\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\n\n\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return createSVGTree(html, root);\n  return createHTMLTree(html, root);\n}\n\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {HTMLFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\n\nfunction injectDOM(el, dom) {\n  switch (true) {\n    case isSvg(el):\n      moveChildren(dom, el);\n      break;\n\n    case isTemplate(el):\n      el.parentNode.replaceChild(dom, el);\n      break;\n\n    default:\n      el.appendChild(dom);\n  }\n}\n\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string} html - markup that will be injected into the root node\n * @returns {HTMLFragment} fragment that will be injected into the root node\n */\n\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);\n}\n/**\n * Template Chunk model\n * @type {Object}\n */\n\n\nconst TemplateChunk = Object.freeze({\n  // Static props\n  // bindings: null,\n  // bindingsData: null,\n  // html: null,\n  // isTemplateTag: false,\n  // fragment: null,\n  // children: null,\n  // dom: null,\n  // el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html);\n    return this;\n  },\n\n  // API methods\n\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta) {\n    if (meta === void 0) {\n      meta = {};\n    }\n\n    if (!el) throw new Error('Please provide DOM node to mount properly your template');\n    if (this.el) this.unmount(scope); // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n\n    const {\n      fragment,\n      children,\n      avoidDOMInjection\n    } = meta; // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n\n    const {\n      parentNode\n    } = children ? children[0] : el;\n    const isTemplateTag = isTemplate(el);\n    const templateTagOffset = isTemplateTag ? Math.max(Array.from(parentNode.childNodes).indexOf(el), 0) : null;\n    this.isTemplateTag = isTemplateTag; // create the DOM if it wasn't created before\n\n    this.createDOM(el);\n\n    if (this.dom) {\n      // create the new template dom fragment if it want already passed in via meta\n      this.fragment = fragment || this.dom.cloneNode(true);\n    } // store root node\n    // notice that for template tags the root note will be the parent tag\n\n\n    this.el = this.isTemplateTag ? parentNode : el; // create the children array only for the <template> fragments\n\n    this.children = this.isTemplateTag ? children || Array.from(this.fragment.childNodes) : null; // inject the DOM into the el only if a fragment is available\n\n    if (!avoidDOMInjection && this.fragment) injectDOM(el, this.fragment); // create the bindings\n\n    this.bindings = this.bindingsData.map(binding => create$5(this.el, binding, templateTagOffset));\n    this.bindings.forEach(b => b.mount(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.el) {\n      this.bindings.forEach(b => b.unmount(scope, parentScope, mustRemoveRoot));\n\n      switch (true) {\n        // <template> tags should be treated a bit differently\n        // we need to clear their children only if it's explicitly required by the caller\n        // via mustRemoveRoot !== null\n        case this.children && mustRemoveRoot !== null:\n          clearChildren(this.children);\n          break;\n        // remove the root node only if the mustRemoveRoot === true\n\n        case mustRemoveRoot === true:\n          removeNode(this.el);\n          break;\n        // otherwise we clean the node children\n\n        case mustRemoveRoot !== null:\n          cleanNode(this.el);\n          break;\n      }\n\n      this.el = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return Object.assign({}, this, {\n      el: null\n    });\n  }\n\n});\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {Array} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\n\nfunction create$6(html, bindings) {\n  if (bindings === void 0) {\n    bindings = [];\n  }\n\n  return Object.assign({}, TemplateChunk, {\n    html,\n    bindingsData: bindings\n  });\n}\n\n/**\n * Method used to bind expressions to a DOM node\n * @param   {string|HTMLElement} html - your static template html structure\n * @param   {Array} bindings - list of the expressions to bind to update the markup\n * @returns {TemplateChunk} a new TemplateChunk object having the `update`,`mount`, `unmount` and `clone` methods\n *\n * @example\n *\n * riotDOMBindings\n *  .template(\n *   `<div expr0><!----></div><div><p expr1><!----><section expr2></section></p>`,\n *   [\n *     {\n *       selector: '[expr0]',\n *       redundantAttribute: 'expr0',\n *       expressions: [\n *         {\n *           type: expressionTypes.TEXT,\n *           childNodeIndex: 0,\n *           evaluate(scope) {\n *             return scope.time;\n *           },\n *         },\n *       ],\n *     },\n *     {\n *       selector: '[expr1]',\n *       redundantAttribute: 'expr1',\n *       expressions: [\n *         {\n *           type: expressionTypes.TEXT,\n *           childNodeIndex: 0,\n *           evaluate(scope) {\n *             return scope.name;\n *           },\n *         },\n *         {\n *           type: 'attribute',\n *           name: 'style',\n *           evaluate(scope) {\n *             return scope.style;\n *           },\n *         },\n *       ],\n *     },\n *     {\n *       selector: '[expr2]',\n *       redundantAttribute: 'expr2',\n *       type: bindingTypes.IF,\n *       evaluate(scope) {\n *         return scope.isVisible;\n *       },\n *       template: riotDOMBindings.template('hello there'),\n *     },\n *   ]\n * )\n */\n\nvar DOMBindings = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  template: create$6,\n  createBinding: create$5,\n  createExpression: create$2,\n  bindingTypes: bindingTypes,\n  expressionTypes: expressionTypes\n});\n\nfunction noop() {\n  return this;\n}\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\n\nfunction autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source);\n  });\n  return source;\n}\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\n\nfunction callOrAssign(source) {\n  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;\n}\n\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\nfunction defineProperty(source, key, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, Object.assign({\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source;\n}\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\n\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach((_ref) => {\n    let [key, value] = _ref;\n    defineProperty(source, key, value, options);\n  });\n  return source;\n}\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\n\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach((_ref2) => {\n    let [key, value] = _ref2;\n    if (!source[key]) source[key] = value;\n  });\n  return source;\n}\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  } // this object could be looped out of the box\n\n\n  return els;\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\n\nfunction $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);\n}\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\n\nconst normalize = values => values.length === 1 ? values[0] : values;\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\n\n\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\n\n\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : {\n    [name]: value\n  };\n  const props = Object.keys(attrs);\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els;\n}\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\n\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute');\n}\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nvar cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn) {\n  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    acc[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args = [...acc, ...args];\n    return args.length < fn.length ? curry(fn, ...args) : fn(...args);\n  };\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\nconst COMPONENT_CORE_HELPERS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\nconst PURE_COMPONENT_API = Object.freeze({\n  [MOUNT_METHOD_KEY]: noop,\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY]: noop\n});\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  [SHOULD_UPDATE_KEY]: noop,\n  [ON_BEFORE_MOUNT_KEY]: noop,\n  [ON_MOUNTED_KEY]: noop,\n  [ON_BEFORE_UPDATE_KEY]: noop,\n  [ON_UPDATED_KEY]: noop,\n  [ON_BEFORE_UNMOUNT_KEY]: noop,\n  [ON_UNMOUNTED_KEY]: noop\n});\nconst MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {\n  clone: noop,\n  createDOM: noop\n});\n/**\n * Evaluate the component properties either from its real attributes or from its initial user properties\n * @param   {HTMLElement} element - component root\n * @param   {Object}  initialProps - initial props\n * @returns {Object} component props key value pairs\n */\n\nfunction evaluateInitialProps(element, initialProps) {\n  if (initialProps === void 0) {\n    initialProps = {};\n  }\n\n  return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));\n}\n/**\n * Bind a DOM node to its component object\n * @param   {HTMLElement} node - html node mounted\n * @param   {Object} component - Riot.js component object\n * @returns {Object} the component object received as second argument\n */\n\n\nconst bindDOMNodeToComponentObject = (node, component) => node[DOM_COMPONENT_INSTANCE_PROPERTY] = component;\n/**\n * Wrap the Riot.js core API methods using a mapping function\n * @param   {Function} mapFunction - lifting function\n * @returns {Object} an object having the { mount, update, unmount } functions\n */\n\n\nfunction createCoreAPIMethods(mapFunction) {\n  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {\n    acc[method] = mapFunction(method);\n    return acc;\n  }, {});\n}\n/**\n * Factory function to create the component templates only once\n * @param   {Function} template - component template creation function\n * @param   {Object} components - object containing the nested components\n * @returns {TemplateChunk} template chunk object\n */\n\n\nfunction componentTemplateFactory(template, components) {\n  return template(create$6, expressionTypes, bindingTypes, name => {\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name);\n  });\n}\n/**\n * Create a pure component\n * @param   {Function} pureFactoryFunction - pure component factory function\n * @param   {Array} options.slots - component slots\n * @param   {Array} options.attributes - component attributes\n * @param   {Array} options.template - template factory function\n * @param   {Array} options.template - template factory function\n * @param   {any} options.props - initial component properties\n * @returns {Object} pure component object\n */\n\n\nfunction createPureComponent(pureFactoryFunction, _ref) {\n  let {\n    slots,\n    attributes,\n    props,\n    css,\n    template\n  } = _ref;\n  if (template) panic('Pure components can not have html');\n  if (css) panic('Pure components do not have css');\n  const component = defineDefaults(pureFactoryFunction({\n    slots,\n    attributes,\n    props\n  }), PURE_COMPONENT_API);\n  return createCoreAPIMethods(method => function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // intercept the mount calls to bind the DOM node to the pure object created\n    // see also https://github.com/riot/riot/issues/2806\n    if (method === MOUNT_METHOD_KEY) {\n      const [el] = args;\n      bindDOMNodeToComponentObject(el, component);\n    }\n\n    component[method](...args);\n    return component;\n  });\n}\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {string} options.css - component css\n * @param   {Function} options.template - functon that will return the dom-bindings template function\n * @param   {Object} options.exports - component interface\n * @param   {string} options.name - component name\n * @returns {Object} component like interface\n */\n\n\nfunction createComponent(_ref2) {\n  let {\n    css,\n    template,\n    exports,\n    name\n  } = _ref2;\n  const templateFn = template ? componentTemplateFactory(template, exports ? createSubcomponents(exports.components) : {}) : MOCKED_TEMPLATE_INTERFACE;\n  return (_ref3) => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref3;\n    // pure components rendering will be managed by the end user\n    if (exports && exports[IS_PURE_SYMBOL]) return createPureComponent(exports, {\n      slots,\n      attributes,\n      props,\n      css,\n      template\n    });\n    const componentAPI = callOrAssign(exports) || {};\n    const component = defineComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components create via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Component definition function\n * @param   {Object} implementation - the componen implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction defineComponent(_ref4) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref4;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    [STATE_KEY]: {}\n  })), Object.assign({\n    // defined during the component creation\n    [SLOTS_KEY]: null,\n    [ROOT_KEY]: null\n  }, COMPONENT_CORE_HELPERS, {\n    name,\n    css,\n    template\n  })));\n}\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  const expressions = attributes.map(a => create$2(node, a));\n  const binding = {};\n  return Object.assign(binding, Object.assign({\n    expressions\n  }, createCoreAPIMethods(method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  })));\n}\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\n\nfunction createSubcomponents(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref5) => {\n    let [key, value] = _ref5;\n    acc[camelToDashCase(key)] = createComponent(value);\n    return acc;\n  }, {});\n}\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component);\n}\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state givent to the `update` call\n * @returns {Object} new object state\n */\n\n\nfunction computeState(oldState, newState) {\n  return Object.assign({}, oldState, callOrAssign(newState));\n}\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, IS_DIRECTIVE, name);\n  }\n}\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\n\nfunction enhanceComponentAPI(component, _ref6) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref6;\n  return autobindMethods(runPlugins(defineProperties(Object.create(component), {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, evaluateInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node\n\n      bindDOMNodeToComponentObject(element, this); // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, ROOT_KEY, element); // define the slots array\n\n      defineProperty(this, SLOTS_KEY, slots); // before mount lifecycle event\n\n      this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[PARENT_KEY_SYMBOL] = parentScope; // mount the template\n\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      if (parentScope) {\n        this[PARENT_KEY_SYMBOL] = parentScope;\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false) return;\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);\n      this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount(); // if the preserveRoot is null the template html will be left untouched\n      // in that case the DOM cleanup will happen differently from a parent node\n\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);\n      this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({\n    props: initialProps\n  });\n  return component.mount(element);\n}\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nconst {\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,\n  PLUGINS_SET: PLUGINS_SET$1\n} = globals;\n/**\n * Riot public api\n */\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.set(name, createComponent({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\n\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP$1.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP$1;\n}\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of nodes upgraded\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {boolean|null} keepRootElement - if true keep the root element\n * @returns {Array} list of nodes unmounted\n */\n\nfunction unmount(selector, keepRootElement) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY$1]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY$1].unmount(keepRootElement);\n    }\n\n    return element;\n  });\n}\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET$1.has(plugin)) panic('This plugin was already installed');\n  PLUGINS_SET$1.add(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET$1.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET$1.delete(plugin);\n  return PLUGINS_SET$1;\n}\n/**\n * Helper method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\n\nfunction component(implementation) {\n  return function (el, props, _temp) {\n    let {\n      slots,\n      attributes,\n      parentScope\n    } = _temp === void 0 ? {} : _temp;\n    return compose(c => c.mount(el, parentScope), c => c({\n      props,\n      slots,\n      attributes\n    }), createComponent)(implementation);\n  };\n}\n/**\n * Lift a riot component Interface into a pure riot object\n * @param   {Function} func - RiotPureComponent factory function\n * @returns {Function} the lifted original function received as argument\n */\n\nfunction pure(func) {\n  if (!isFunction(func)) panic('riot.pure accepts only arguments of type \"function\"');\n  func[IS_PURE_SYMBOL] = true;\n  return func;\n}\n/** @type {string} current riot version */\n\nconst version = 'v4.13.4'; // expose some internal stuff that might be used from external tools\n\nconst __ = {\n  cssManager,\n  DOMBindings,\n  createComponent,\n  defineComponent,\n  globals\n};\n\nexport { __, component, install, mount, pure, register, uninstall, unmount, unregister, version };\n","import App from './App.riot'\nimport {component} from 'riot'\n\ncomponent(App)(document.querySelector('#root'), {\n  message: 'Hello there'\n})"]}